// args: --run

def solve[n:!â„•](p:!â„•,inputRegister:ğ”¹^n){
	x:=inputRegister as uint[n];
	with (k,x):=estimatePhase[2](QFT[n],x) do {
		rep(k,()â‡’phase(Ï€/(2Â·p)),());
	}
	return x as ğ”¹^n;
}

def sqrtQFT[n:!â„•](x:uint[n])â‡’solve(2, x as ğ”¹^n) as uint[n];
def cbrtQFT[n:!â„•](x:uint[n])â‡’solve(3, x as ğ”¹^n) as uint[n];

def main(){
	a:=reverse(QFT)(sqrtQFT(sqrtQFT(2:uint[2])));
	b:=reverse(QFT)(cbrtQFT(cbrtQFT(cbrtQFT(3:uint[2]))));
	assert(measure((a,b)=(2,3)));
	return (a,b);
}


def estimatePhase[n:!â„•][a:qtype](f:a!â†’mfree a,x:a)mfree{
	p:=mapH(0:uint[n]);
	x:=rep(p,f,x);
	p:=reverse(QFT)(p);
	return (p,x);
}

def QFT[n:!â„•](Ïˆ:uint[n])mfree: uint[n]{
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	for k in [0..n){
		Ïˆ[k] := H(Ïˆ[k]);
		for l in [k+1..n){
			if Ïˆ[k] && Ïˆ[l]{
				phase(2Â·Ï€Â·2^(k-l-1));
			}
		}
	}
	return Ïˆ;
}

def mapH[n:!â„•](x:uint[n])mfree{
	for i in 0..n{
		x[i]:=H(x[i]);
	}
	return x;
}

def rep[n:!â„•,a:qtype](const k:uint[n],f:a!â†’mfree a,x:a)mfree{
	for i in 0..2^n{
		if k<i{
			x:=f(x);
		}
	}
	return x;
}
