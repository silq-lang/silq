// args: --run

def toW[n:!]lifted:^n mfree ^nlambda(qs:^n)mfree:^n{
	if n==1{ qs[0]:=X(qs[0]); }
	else if n>1{
		胃:=asin(1/sqrt(n));
		(([head] coerce ^1):[])~((tail coerce ^(n sub 1)):[]):=(qs:[]);
		head:=rotY(胃,head);
		if !head { tail := toW(tail); }
		qs:=[head]~(tail:[]) coerce B^n;
	}
	return qs;
};

def fromW[n:!]lifted:^nmfree ^nlambda(qs:^n)mfree:^n{
    if n = 1 {
        qs[0] := reverse(X)(qs[0]);
    } else if n > 1 {
        胃 := asin(1 / sqrt(n));
        __tmp2 := qs coerce [];
        (head,) := __tmp2[0..1] coerce ^1;
        tail := __tmp2[1..__tmp2.length] coerce ^((n sub 1));
        forget(__tmp2=[head] ~ (tail: []));
        if 卢head {
            tail := fromW(tail);
        }
        head := reverse(rotY)(胃,head);
        __tmp0 := dup((([head] coerce  ^ 1): []) ~ ((tail coerce  ^ (n sub 1)): []));
        forget(tail=(__tmp0[1..__tmp0.length]: []) coerce  ^ (n sub 1));
        forget((head,)=(__tmp0[0..1]: []) coerce  ^ 1);
        qs := __tmp0 coerce ^n;
    }
    return qs;
};

def solve(qs:^3):!{
	if qs[1]{ phase(-2路/3); }
	if qs[2]{ phase(-4路/3); }
	qs:=fromW(qs);
 	return measure(qs as int[3])!=0;
}
def main(){
	qs:=toW(vector(3,0:));
	if qs[1]{ phase(2路/3); }
	if qs[2]{ phase(4路/3); }
	assert(!solve(qs));
}
