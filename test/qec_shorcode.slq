// args: --run

def map[a,b](const f:aâ†’mfree b)[n:!â„•](xs:a^n):b^n{
	ys:=();
	for i in 0..n{
		[x]~xs:=xs;
		ys~=[f(x)];
	}
	():=xs;
	return ys coerce b^n;
}

//def bit_encode[m:!â„•](x:ğ”¹):ğ”¹^m â‡’ vector(m sub 1,x)~[x]; // TODO
def bit_encode[m:!â„•](x:ğ”¹):ğ”¹^m{
	r:=();
	for i in 0..m-1{
		r~=[dup(x)];
	}
	r~=[x];
	return r coerce ğ”¹^m;
}
def bit_decode[m:!â„•](xs:ğ”¹^m):ğ”¹â‡’reverse(bit_encode)(xs);

def bit_syndrome[m:!â„•](xs:ğ”¹^m){
	s:=();
	for i in 0..m-1{
		s~=[measure(xs[i]âŠ•xs[i+1])];
	}
	return (xs,s coerce !ğ”¹^(m sub 1));
}

def bit_flips[m:!â„•](s:!ğ”¹^(m sub 1)){
	flips:=vector(m,0);
	nflips:=0;
	for i in 0..m-1{
		flips[i+1]=flips[i]âŠ•s[i];
		nflips+=flips[i+1];
	}
	if nflips>m/2{
		for i in 0..m{
			flips[i]:=X(flips[i]);
		}
	}
	return flips;
}

def bit_apply_fix[m:!â„•](xs:ğ”¹^m,s:!ğ”¹^(m sub 1)){
	flips:=bit_flips[m](s);
	for i in 0..m{
		if flips[i]{
			xs[i]:=X(xs[i]);
		}
	}
	return xs;
}

def bit_fix[m:!â„•](xs:ğ”¹^m):ğ”¹^m â‡’ bit_apply_fix(bit_syndrome(xs));

def phase_encode[n:!â„•](x:ğ”¹):ğ”¹^n â‡’ map(H)(bit_encode[n](x));
def phase_decode[n:!â„•](xs:ğ”¹^n):ğ”¹ â‡’ reverse(phase_encode)(xs);

def phase_syndrome[n:!â„•](xs:ğ”¹^n):ğ”¹^nÃ—!ğ”¹^(n sub 1){
	with xs:=map(H)(xs) do (xs,s):=bit_syndrome(xs);
	return (xs,s);
}

def phase_apply_fix[n:!â„•](xs:ğ”¹^n,s:!ğ”¹^(n sub 1)){
	flips:=bit_flips[n](s);
	for i in 0..n{
		if flips[i]{
			xs[i]:=Z(xs[i]);
		}
	}
	return xs;	
}

def phase_fix[n:!â„•](xs:ğ”¹^n):ğ”¹^n â‡’ phase_apply_fix(phase_syndrome(xs));

def shor_encode[n:!â„•,m:!â„•](x:ğ”¹):(ğ”¹^m)^n{
	xs:=phase_encode[n](x);
	return map(bit_encode[m])(xs);
}
def shor_decode[n:!â„•,m:!â„•](xs:(ğ”¹^m)^n)â‡’reverse(shor_encode)(xs);

def shor_syndrome[n:!â„•,m:!â„•](xs:(ğ”¹^m)^n):(ğ”¹^m)^nÃ—(!ğ”¹^(m sub 1))^nÃ—!ğ”¹^(n sub 1){
	sbs:=();
	for i in 0..n{
		(xs[i],sb):=bit_syndrome(xs[i]);
		sbs~=[sb];
	}
	sbs:=sbs coerce _^n;
	sp:=map(H)(vector(n sub 1,0));
	for i in 0..n-1{
		for j in 0..m{
			xs[i][j]âŠ•=sp[i];
			xs[i+1][j]âŠ•=sp[i];
		}
	}
	sp:=measure(map(H)(sp));
	return (xs,sbs,sp)
}

def shor_apply_fix[n:!â„•,m:!â„•](xs:(ğ”¹^m)^n,sbs:(!ğ”¹^(m sub 1))^n,sp:!ğ”¹^(n sub 1)){
	for i in 0..n{
		xs[i]:=bit_apply_fix(xs[i],sbs[i]);
	}
	flips:=bit_flips(sp);
	for i in 0..n{
		if flips[i]{
			xs[i][0]:=Z(xs[i][0]);
		}
	}
	return xs;	
}

def shor_fix[n:!â„•,m:!â„•](xs:(ğ”¹^m)^n):(ğ”¹^m)^n â‡’ shor_apply_fix(shor_syndrome(xs));

def main(){
	x:=H(0);
	xs:=shor_encode[3,3](x);
	xs[0][0]:=H(xs[0][0]);
	xs[1][0]:=X(xs[1][0]);
	xs[1][1]:=measure(xs[1][1]);
	xs[2][1]:=Z(xs[2][1]);
	xs[2][2]:=X(xs[2][2]);
	xs:=shor_fix(xs);
	x:=shor_decode(xs);
	assert(measure(H(x))=0);
}
