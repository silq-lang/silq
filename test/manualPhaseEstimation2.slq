// skipped
// args: --run --project-forget

def logâ‚‚(k:!â„•)qfree:!â„• â‡’ if k=1 then 0 else 1+logâ‚‚((k+1) div 2);
def majority[n:!â„•](x:ğ”¹^n)lifted{
	count:=0:uint[logâ‚‚(n+1)];
	for i in 0..n{ count+=x[i]; }
	return count>n div 2;
}

def phaseQ[n:!â„•](const Ï†:uint[n])mfree{
	for i in [0..n){ if Ï†[i]{ phase(2Â·Ï€Â·2^i/2^n); } }
}
n:=3;
m:=2;
def main(){
	Ï†:=5:uint[n];
	Ï†[0]:=H(Ï†[0]);
	U:=[k:!â„•](Ï†:uint[n])mfree{
		phaseQ(2^kÂ·Ï†);
		return Ï†;
	};
	estimate:=0:uint[m];
	samples:=5;
	for i in 0..m{
		def get_cands(const estimate:uint[m],Ï†:uint[n])mfree{
			cands:=[]:ğ”¹[];
			for k in 0..samples{
				x:=H(0:ğ”¹);
				if x{
					Ï†:=U[m sub 1 sub i](Ï†);
					phaseQ(-2^(m sub 1 sub i)Â·estimate);
				}
				cands~=[H(x)];
			}
			return (cands coerce ğ”¹^samples,Ï†);
		};
		def get_majority(const estimate:uint[m],Ï†:uint[n]){
			(cands,Ï†):=get_cands(estimate,Ï†);
			result:=majority(cands);
			get_cands(estimate,Ï†):=(cands,Ï†);
			return (result,Ï†);
		};
		(x,Ï†):=get_majority(estimate,Ï†);
		(estimate[i],x):=(x,estimate[i]);
		forget(x=0);
	}
	return (Ï†,estimate);
}
