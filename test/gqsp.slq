// GQSP (motlag-wiebe)
// https://arxiv.org/abs/2308.01501

def fft[N:!â„•](xs:!â„‚^N):!â„‚^N {
	if N=1 { return xs; }
	assert(N%2=0);
	xs_e:=vector(N div 2,0);
	xs_o:=vector(N div 2,0);
	for j in 0..N div 2{
		xs_e[j]=xs[2Â·j];
		xs_o[j]=xs[2Â·j+1];
	}
	ys_e:=fft(xs_e);
	ys_o:=fft(xs_o);
	ys:=vector(N,0);
	for k in 0..N div 2{
		t:=cis(-2Â·Ï€Â·k/N)Â·ys_o[k];
		ys[k]=ys_e[k]+t;
		ys[k+N div 2]=ys_e[k]-t;
	}
	return ys;
}
def ifft[N:!â„•](ys:!â„‚^N):!â„‚^N {
	for i in 0..N{ ys[i]:=conj(ys[i]); }
	xs:=fft(ys);
	for i in 0..N{ xs[i]:=conj(xs[i])/N; }
	return xs;
}

def poly_eval[d:!â„•](coeffs:!â„‚^(d+1))(x:!â„‚):!â„‚{
	r:=coeffs[d];
	for i in (d..-1..0]{
		r=rÂ·x+coeffs[i];
	}
	return r;
}

def pad[m:!â„•][a:type,n:!â„•](xs:a^n,const x:a):a^mâ‡’xs~vector(m sub n,x);

// berntson-sÃ¼nderhauf
// https://arxiv.org/abs/2406.04246
def thm3_Nâ‚€(Îµ:!â„,Î´:!â„,d:!â„•):!â„•{
	assert(0<Î´âˆ§Î´<1âˆ§0<Îµâˆ§Îµ<1);
	rÎ´:=(1/(1-Î´))^(1/d);
	Nâ‚€:=ceil(2/log(rÎ´)Â·log(8Â·-log(Î´)/(rÎ´-1)/Îµ)) coerce !â„•;
	return ceil(Nâ‚€) coerce !â„•;
}
def heuristic_Nâ‚€(Îµ:!â„,Î´:!â„,d:!â„•):!â„•{
	rÎ´m1:=expm1(-log1p(-Î´)/d);
	Nâ‚€:=ceil(2Â·d/-log1p(-Î´)Â·log(8Â·-log(Î´)/(ÎµÂ·rÎ´m1))) coerce !â„•;
	return ceil(Nâ‚€Â·Î´) coerce !â„•; // seems good enough?
}
def complement_alg1[d:!â„•](p:!â„‚^(d+1),N:!â„•):!â„‚^(d+1){
	ps:=fft(pad[N](p,0));
	â„“:=vector(N,0);
	for j in 0..N { â„“[j]=log(1-cabs(ps[j])^2); }
	â„“:=ifft(â„“);
	log_qs:=fft(pad[N]([â„“[0]/2]~â„“[1..N div 2+1],0));
	qs:=vector(N,0);
	for j in 0..N { qs[j]=cexp(log_qs[j]); }
	return ifft(qs)[0..d+1];
}

def complement_alg2[d:!â„•](p:!â„‚^(d+1),Îµ:!â„,N:!â„•):!â„‚^(d+1){
	for i in 0..d+1{ p[i]Â·=1-Îµ/4; }
	return complement_alg1[d](p,N);
}

def complement[d:!â„•](p:!â„‚^(d+1),Îµ:!â„):!â„‚^(d+1){
	//Nâ‚€:=thm3_Nâ‚€(Îµ/4,Îµ/(5Â·(d+1)),d);
	Nâ‚€:=heuristic_Nâ‚€(Îµ/4,Îµ/(5Â·(d+1)),d);
	N:=2^(ceil(logâ‚‚(max(Nâ‚€,d+1))) coerce !â„•);
	return complement_alg2[d](p,Îµ,N);
}

def is_complement[N:!â„•][d:!â„•](p:!â„‚^(d+1),q:!â„‚^(d+1),Îµ:!â„){
	assert(Nâ‰¥d+1âˆ§(N&(N-1))=0);
	ps:=fft(pad[N](p,0));
	qs:=fft(pad[N](q,0));
	ok:=1;
	for j in 0..N{
		ok&=abs(cabs(ps[j])^2+cabs(qs[j])^2-1)<Îµ;
	}
	return ok;
}

def gqsp_apply_Rdag[d:!â„•](
	Î¸: !â„,
	Ï†: !â„,
	Î»_:!â„,
)(
	P: !â„‚^(d+1),
	Q: !â„‚^(d+1),
):!â„‚^(d+1)Ã—!â„‚^(d+1){
	(c,s):=(cos(Î¸),sin(Î¸));
	ac:=conj(cis(Î»_+Ï†)Â·c);
	bc:=conj(cis(Ï†)Â·s);
	cc:=conj(cis(Î»_)Â·s);
	dc:=conj(-c);

	(Pp,Qp):=vector(2,vector(d+1,0));
	for k in 0..d+1 {
		Pp[k]=acÂ·P[k]+ccÂ·Q[k];
		Qp[k]=bcÂ·P[k]+dcÂ·Q[k];
	}
	return (Pp,Qp);
}

def gqsp_compute_angles[d:!â„•](
	P:!â„‚^(d+1),
	Q:!â„‚^(d+1),
):!â„^(d+1)Ã—!â„^(d+1)Ã—!â„{
	Î¸d:=atan2(cabs(Q[d]),cabs(P[d]));
	Ï†d:=carg(P[d])-carg(Q[d]);
	if d=0 {
		Î»_:=carg(Q[d]);
		return ([Î¸d],[Ï†d],Î»_) coerce !â„^(d+1)Ã—!â„^(d+1)Ã—!â„;
	}
	(Pp,Qp):=gqsp_apply_Rdag[d](Î¸d,Ï†d,0)(P,Q);
	(Î¸s,Ï†s,Î»_):=gqsp_compute_angles[d sub 1](Pp[1..d+1],Qp[0..d]);
	return (Î¸s~[Î¸d],Ï†s~[Ï†d],Î»_);
}

def R(Î¸:!â„,Ï†:!â„,Î»_:!â„)(anc:ğ”¹){
	phase((Ï€+Î»_+Ï†)/2);
	anc:=rotZ(Ï€-Î»_,anc);
	anc:=rotY(2Â·Î¸,anc);
	anc:=rotZ(-Ï†,anc);
	return anc;
}

def gqsp[d:!â„•](
	Î¸s:!â„^(d+1),
	Ï†s:!â„^(d+1),
	Î»_:!â„,
)[a:qtype](const f: a â†’mfree a)(cand: a):ğ”¹Ã—a{
	anc:=R(Î¸s[0],Ï†s[0],Î»_)(0:ğ”¹);
	for j in 1..d+1 {
		if anc=0{ cand:=f(cand); }
		anc:=R(Î¸s[j],Ï†s[j],0)(anc);
	}
	return (anc,cand);
}

def main(){
	p:=(0.07,0.35,0.35,0.2);
	q:=complement[3](p,1e-8);
	print(q);
	assert(is_complement[128][3](p,q,1e-8));
	angles:=gqsp_compute_angles[3](p,q);
	z:=cis(-1/4);
	print(poly_eval[3](p)(z));
	print(poly_eval[3](q)(z));
	return gqsp[3](angles)((x:ğ”¹)â‡’rotZ(1/2,x))(0:ğ”¹);
}
