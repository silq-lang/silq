
def task[state](
	numbers: !â„[],
	prepareState: !(Î (n:!â„•). state^n),
	first: stateÃ—!â„!â†’!ğ”¹^2,
	intermediate: stateÃ—!ğ”¹^2Ã—!â„!â†’!ğ”¹^2,
	last: stateÃ—!ğ”¹^2Ã—!â„!â†’!ğ”¹,
){
	n:=numbers.length;
	Ï†:=prepareState(n):state[];
	[head]~Ï†:=Ï†;
	bits:=first(head,numbers[0]);
	for i in [1..n-1){
		[head]~Ï†:=Ï†;
		bits=intermediate(head,bits,numbers[i]);
	}
	[head]~Ï†:=Ï†;
	result:=last(head,bits,numbers[n-1]);
	[]:=Ï†;
	return result;
}

def cheat(numbers: !â„[]){
	x:=0:!â„;
	for i in [0..numbers.length){
		x+=numbers[i];
	}
	return round(x)%2!=0;
}
def solve(numbers: !â„[])â‡’task[ğ”¹^2](numbers,prepareState,first,intermediate,last);

def prepareState(n:!â„•){
	Ï†:=[]:(ğ”¹^2)[];
	last:=0:ğ”¹;
	for i in [0..n){
		bit:=H(0:ğ”¹);
		next:=dup(bit);
		Ï†~=[(last,bit)];
		last:=next;
	}
	measure(last);
	return Ï† coerce (ğ”¹^2)^n;
}

def send(shared:ğ”¹,message:ğ”¹){
	if message { shared:=X(shared); }
	message:=H(message);
	return measure(shared,message);
}
def receive(shared:ğ”¹,bits:!ğ”¹^2){
	if bits[0]{ shared:=X(shared); }
	if bits[1]{ shared:=Z(shared); }
	return shared;
}

def apply(number:!â„,const qbit:ğ”¹)mfreeâ‡’if qbit then phase(Ï€Â·number) else ();
def first(qbits: ğ”¹^2,number:!â„){
	(_,next):=qbits;
	measure(_);
	qbit:=H(0:ğ”¹);
	apply(number,qbit);
	return send(next,qbit);
}
def intermediate(qbits:ğ”¹^2,bits:!ğ”¹^2,number:!â„){
	(prev,next):=qbits;
	qbit:=receive(prev,bits);
	apply(number,qbit);
	return send(next,qbit);
}
def last(qbits:ğ”¹^2,bits:!ğ”¹^2,number:!â„){
	(prev,_):=qbits;
	measure(_);
	qbit:=receive(prev,bits);
	apply(number,qbit);
	return measure(H(qbit));
}
def main(){
	numbersâ‚€:=[1/2,1/3,1/6,1];
	numbersâ‚:=[1/2,1/2];
	return (solve(numbersâ‚€),solve(numbersâ‚));
}
