/+
def main() {
	forget(2+2=5);
}
+/
/+
def main(){
	x:=0;
	for i in 0..10{
		def foo()â‡’2;
		x+=foo();
	}
	return x;
}
+/

/+
def foo[n:!â„•](const Ï†:uint[n])mfree{}
def main(){
	n:=2;
	Ï†:=3:!uint[n];
	bar:=()mfreeâ‡’foo(Ï†);
	bar();
}
+/

/+
// segfaults with ldc 1.28.0 without -O
def makeF() mfree: 1 â†’ mfree B {
	x := H(0:B);
	return () mfree â‡’ x;
}

def main() {
	f := makeF();
	return f();
}
+/


/+
def main(){
	x:=1:!â„•;
	y:=2:uint[10];
	z:=y sub x; // TODO
	return z;
}
+/

/+
def main(){
	x:=1/2;
	return x|x; // TODO: error
}
+/

/+
def main(){
	x:=0:ğ”¹;
	y:=0:ğ”¹;
	(x,y)[0]=0:ğ”¹; // TODO: error
}
+/
/+
def main(){
	x:=vector(10,0:ğ”¹);
	(x[0],x[1])[0]=1:ğ”¹; // TODO: error
}
+/
/+
+/
/+
def main(){
	[1,2]:=[1,2,3]; // TODO: error
}
+/

/+
def index[n:!â„•](xs:ğ”¹[],i:uint[n])liftedâ‡’xs[i];
def main(){
	x:=vector(10,false):ğ”¹[];
	return index(x,3:uint[10]);
}
+/
/+
def index[n:!â„•](xs:ğ”¹[],i:uint[n])liftedâ‡’xs[i];
def main()â‡’index(vector(10,false),3:uint[10]);
+/

/+
def foo[n:!â„•, rr:!â„•](
	const r:!â„•,
	const ee:(ğ”¹^rr)^rr,
)mfree{
	rbar := max(2 * r div 3, 1) coerce !â„•;
	rrbar := 2^rbar;

	tau := vector(rrbar,0:int[r]);
	for i in [0..rrbar){ for j in [0..r){ tau[i][j]:=H(tau[i][j]); } }
	eew := vector(rrbar,false):B^rrbar;
	for i in [0..rrbar){ eew[i]:=H(eew[i]); }

	// snippet from Figure 2
	cTri := 0:int[rrbar];
	for j in [0..rrbar) {
		for k in [j+1..rrbar) {
			if ee[tau[j]][tau[k]] && eew[j] && eew[k] { // crash
				cTri += 1;
	}	}	}
    // ---------------------
	return (tau as int[r][], eew as ğ”¹[], cTri as ğ”¹[]);
}

def main(){
	return foo[2,2](2,vector(2,vector(2,true)));
}
+/

/+
def main(){
	a:=[]:â„•[]; // TODO: error here?
	a~=[1];
}
+/

//def foo[n:!ğ”¹]()â‡’vector(n,0:ğ”¹);

/+
def main(){
	n:=200; // TODO: make running time scale linearly in n!
	a:=vector(n,1:ğ”¹);
	r:=0:int[32];
	def index(a: ğ”¹^n,i:!â„•)lifted{
		return a[i];
	}
	for i in [0..n){
		r+=a[i];
		r+=index(a,i);
	}
	return r;
}
+/

/+
def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	while(measure(H(0:ğ”¹))){
		forget(y);
		y:=dup(x); // TODO
	}
	return H(x);
}
+/


/+
def arcsin(q:!â„) lifted :!â„;
def sqrt(q:!â„) lifted :!â„;

def WState[n:!N](q0:ğ”¹,q1s:ğ”¹^n)mfree:ğ”¹Ã—ğ”¹^n {
    if n+1==1{
        q0 := X(q0);
    } else {
        theta := arcsin(1.0 / sqrt(n));
        q0 := rotY(2*theta, q0);

        if !q0{
            (q1s[0], q1s[1..n]) := WState[n-1](q1s[0], q1s[1..n]); // TODO
        }
    }
    return (q0, q1s)
}
+/

/+
def arcsin(q:!â„) lifted :!â„;
def sqrt(q:!â„) lifted :!â„;

def WState[n:!N](q0:ğ”¹,q1s:ğ”¹^n)mfree:ğ”¹Ã—ğ”¹^n {
    if n+1==1{
        q0 := X(q0);
    } else {
        theta := arcsin(1.0 / sqrt(n));
        q0 := rotY(2*theta, q0);

        if !q0{
            (q1s[0], q1s[1..n]) := WState[n sub 1](q1s[0], q1s[1..n]); // TODO
        }
    }
    return (q0, q1s)
}
+/

/+
def arcsin(q:!â„) lifted :!â„;
def sqrt(q:!â„) lifted :!â„;

def WState[n:!N](q0:ğ”¹,q1s:ğ”¹^n)mfree:ğ”¹Ã—ğ”¹^n {
    if n+1==1{
        q0 := X(q0);
    } else {
        theta := arcsin(1.0 / sqrt(n));
        q0 := rotY(2*theta, q0);

        if !q0{
            (q1s[0], q1s[1..n]) := WState[n-1 coerce !â„•](q1s[0], q1s[1..n]); // TODO
        }
    }
    return (q0, q1s)
}
+/


