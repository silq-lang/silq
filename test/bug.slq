/+
/+
A solution to Renatoâ€™s communication game:
n players, who can communicate only two classical bits on a chain: Aâ‚ â†’ Aâ‚‚ -> Aâ‚ƒ â‹¯ â†’ Aâ‚™ -> Referee
Each player Aáµ¢ receives as input a real number Î±áµ¢. Promise: the sum of all {Î±áµ¢} is a natural number K.
Last player Aâ‚™ should tell the referee whether K is even or odd.
Players are allowed to share a strategy (in particular, to share a large entangled state) before the game starts (i.e. before they know the Î±s).
+/

/+
Solution idea: The players can propagate a single qubit x with quantum teleportation.
The first player prepares the qubit in the |+âŸ© state and the i-th player changes
the phase of |1âŸ© by Ï€Â·Î±áµ¢. In the end, x is in the state
+/

def makeTeleporter(){ // quantum teleportation with send and receive ends
	sharedâ‚€:=H(0:ğ”¹);
	sharedâ‚:=dup(sharedâ‚€);
	def send(message:ğ”¹){
		if message { sharedâ‚€:=X(sharedâ‚€); }
		return measure(sharedâ‚€,H(message));
	}
	def receive(bits:!ğ”¹^2){
		if bits[0]{ sharedâ‚:=X(sharedâ‚); }
		if bits[1]{ sharedâ‚:=Z(sharedâ‚); }
		return sharedâ‚;
	}
	return (send,receive); // type system checks that send and receive are used twice
}

def fill[Ï„](n:!â„•,f:ğŸ™!â†’Ï„):Ï„^nâ‡’if n==0 then ()coerce Ï„^n else fillVec(n sub 1,f)~(f(),);

def prepareState(n:!â„•){
	Ï†:=fill(n+1,makeTeleporter); // create a quantum teleportation channel for each player
	for i in (n..-1..0]{ // distribute receive ends to make ring topology
		(Ï†[i][1],Ï†[i+1][1]):=(Ï†[i+1][1],Ï†[i][1]);
	}
	return Ï†;
}
def apply(Î±:!â„,const qbit:ğ”¹)mfree{
	if qbit { phase(Ï€Â·Î±); }
}
def start(send:ğ”¹â†’!ğ”¹^2,Î±:!â„){
	x:=H(0:ğ”¹);
	apply(Î±,x);
	return send(x);
}
def forward(send:ğ”¹â†’!ğ”¹^2,receive:!ğ”¹^2â†’ğ”¹,bits:!ğ”¹^2,Î±:!â„){
	x:=receive(bits);
	apply(Î±,x);
	return send(x);
}
def end(receive:!ğ”¹^2â†’ğ”¹,bits:!ğ”¹^2,Î±:!â„){
	x:=receive(bits);
	apply(Î±,x);
	return measure(H(x));
}
def solve[n:!â„•](Î±:!â„^n){
	Ï†:=prepareState(n):((ğ”¹â†’!ğ”¹^2)Ã—(!ğ”¹^2â†’ğ”¹))[];
	[(send,receive)]~Ï†:=Ï†;
	measure(receive);
	bits:=start(send,Î±[0]);
	for i in [1..n){
		[(send,receive)]~Ï†:=Ï†;
		bits=forward(send,receive,bits,Î±[i]);
	}
	[(send,receive)]~Ï†:=Ï†;
	measure(send,Ï†);
	return end(receive,bits,Î±[n-1]);
}

def main(){
	Î±â‚€:=(1/2,1/3+sqrt(3),1/3,1/2-sqrt(3),1/3); // K=2
	Î±â‚:=(1/2,3-sqrt(2),1/3,1/6,1+sqrt(2)); // K=5
	return (solve(Î±â‚€),solve(Î±â‚));
}
+/

/+
def makeTeleporter(){
	(sharedâ‚€,sharedâ‚):=vector(2,H(0:ğ”¹));
	sharedâ‚:=dup(sharedâ‚€);
	def send(message:ğ”¹){
		if message { sharedâ‚€:=X(sharedâ‚€); }
		message:=H(message);
		return measure(sharedâ‚€,message);
	}
	def receive(bits:!ğ”¹^2){
		if bits[0]{ sharedâ‚:=X(sharedâ‚); }
		if bits[1]{ sharedâ‚:=Z(sharedâ‚); }
		return sharedâ‚;
	}
	return (send,receive);
}
def fillVec[Ï„](n:!â„•,f:ğŸ™!â†’Ï„):Ï„^nâ‡’if n==0 then ()coerce Ï„^n else fillVec(n sub 1,f)~(f(),);
def prepareState(n:!â„•){
	Ï†:=fillVec(n,makeTeleporter);
	for i in (n-1..-1..0]{ (Ï†[i][1],Ï†[i+1][1]):=(Ï†[i+1][1],Ï†[i][1]); }
	return Ï†;
}
def apply(number:!â„,const qbit:ğ”¹)mfreeâ‡’if qbit then phase(Ï€Â·number) else ();
def start(send:ğ”¹â†’!ğ”¹^2,number:!â„){
	x:=H(0:ğ”¹);
	apply(number,x);
	return send(x);
}
def forward(send:ğ”¹â†’!ğ”¹^2,receive:!ğ”¹^2â†’ğ”¹,bits:!ğ”¹^2,number:!â„){
	x:=receive(bits);
	apply(number,x);
	return send(x);
}
def end(receive:!ğ”¹^2â†’ğ”¹,bits:!ğ”¹^2,number:!â„){
	x:=receive(bits);
	apply(number,x);
	return measure(H(x));
}
def solve[n:!â„•](numbers:!â„^n){
	Ï†:=prepareState(numbers.length):((ğ”¹â†’!ğ”¹^2)Ã—(!ğ”¹^2â†’ğ”¹))[];
	[(send,receive)]~Ï†:=Ï†;
	measure(receive);
	bits:=start(send,numbers[0]);
	for i in [1..n-1){
		[(send,receive)]~Ï†:=Ï†;
		bits=forward(send,receive,bits,numbers[i]);
	}
	[(send,receive)]~Ï†:=Ï†;
	measure(send,Ï†);
	return end(receive,bits,numbers[n-1]);
}
def main(){
	numbersâ‚€:=(1/2,1/3+sqrt(3),1/3,1/2-sqrt(3),1/3); // sum: 2
	numbersâ‚:=(1/2,3-sqrt(2),1/3,1/6,1+sqrt(2)); // sum: 5
	return (solve(numbersâ‚€),solve(numbersâ‚));
}
+/

//def prepareState(n:!â„•):(ğ”¹^2)[]{}

/+
def test[estate](
	prepareState: Î (n:!â„•) â†’ estate^n
){

}
+/
/+
def foo[n:!ğ”¹](){
	qs:=vector(n,0:ğ”¹);
	return qs;
}
+/
/+
def main(){
	f:=(g:ğ”¹Ã—ğ”¹const ğŸ™â†’ğ”¹)â‡’g(false,false,()); // crash
}
+/
/+
def main(){
	n:=100; // TODO: make running time scale linearly in n!
	a:=vector(n,1:ğ”¹);
	r:=0:int[32];
	def index(a: ğ”¹^n,i:!â„•)lifted{
		return a[i];
	}
	for i in [0..n){
		r+=a[i];
		r+=index(a,i);
	}
	return r;
}
+/
/+
def bar(const x:ğ”¹):!â„•{
	if x { return 0; } // TODO: error
	else { return 1; }
}
+/
/+def main(){
	x:=0:ğ”¹;
	y:=0:ğ”¹;
	while(measure(H(0:ğ”¹))){
		x=H(dup(y)); // TODO: error
	}
	return x;
}+/
/+def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	while(measure(H(0:ğ”¹))){
		forget(y);
		y:=dup(x); // TODO
	}
	return H(x);
}+/
/+
def main(){
	x:=0:int[32];
	for i in [0..4){ x[i]=H(x[i]); } // TODO: error
	return x;
}
+/
/+

def arcsin(q:!â„) lifted :!â„;
def sqrt(q:!â„) lifted :!â„;

def WState[n:!N](q0:ğ”¹,q1s:ğ”¹^n) {
    if n+1==1{
        q0 := X(q0);
    } else {
        theta := arcsin(1.0 / sqrt(n));
        q0 := rotY(2*theta, q0);

        if !q0{
            (q1s[0], q1s[1..n]) := WState[n-1](q1s[0], q1s[1..n]); // TODO
        }
    }
    return (q0, q1s)
}
+/

/+
def main(){
	x := 0;
	forget(x); // TODO: remove x, even if classical
	return x;  // TODO: error
}
+/
/+
def main(){
	x := 0:ğ”¹;
	for i in [0..10){
		forget(x); // TODO: error!
		x := H(0:ğ”¹);
	}
	return x;
}
+/
