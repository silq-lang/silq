


/+
def bar(x: !Î (n:!â„•^1)qfree. ğ”¹^n)qfreeâ‡’x(3,); // crash
def zeros(m:!â„•,)qfreeâ‡’vector(m,0:ğ”¹);
def main()â‡’bar(zerosâ‚);
+/

/+
def f(x:ğ”¹^2,const y:ğ”¹)qfree:ğ”¹^2â‡’x;
def main(){
	x:=(H(0:B),);
	y:=H(0:B);
	f(x,y):=x; // TODO: error
	return (x,y);
}
+/

/+
def polyPauliRotY[d:!â„•](coeffs:!â„^(d+1))[n:!â„•](const state:ğ”¹^n,target:a)mfree{
	rotation_coeffs:=vector(2^n,0:!â„);
	rotation_coeffs=for2_(0,d+1)((i:!â„•,rotation_coeffs:!â„^(2^n),mcoeffs:!â„•^(2^n))qfree{
		nrotation_coeffs:=mkvec(2^n)((j:!â„•)qfreeâ‡’rotation_coeffs[j]+coeffs[i]*mcoeffs[j]);
		if i<d { ncoeffs:=nextCoeffs(mcoeffs); }
		else{ ncoeffs:=mcoeffs; }
		return (nrotation_coeffs,ncoeffs);
	})(rotation_coeffs,mkvec(2^n)((i:!â„•)qfreeâ‡’(i=0):!â„•))[0];
	target:=for_(0,2^n)((i:!â„•,const state:ğ”¹^n,target:ğ”¹)mfree{
		if rotation_coeffs[i]!=0{
			mask:=i as !uint[n] as !ğ”¹^n;
			def rec(const state:ğ”¹^n,const mask:!ğ”¹^n,j:!â„•,target:a)mfree:aâ‡’
				if nâ‰¤j then rotY(rotation_coeffs[i],target)
				else if mask[j] then if state[j] then rec(state,mask,j+1,target) else target
				else rec(state,mask,j+1,target);
			target:=rec(state,mask,0,target);
		}
		return target
	})(state,target);
	return target;
}
+/

/+

def mkvec(n:!â„•)[a](f:!â„•!â†’qfree a)qfree:!a^n â‡’ if n=0 then () coerce !a^n else mkvec(n sub 1)(f)~(f(n sub 1),);

def nextCoeffs[n:!â„•](mcoeffs:!â„•^(2^n))qfree â‡’ mkvec(2^n)((i:!â„•)qfree{
	mask:=i as !uint[n];
	def sum(j:!â„•)qfree:!â„• â‡’ if j<n then (if mask[j] then 2^jÂ·(mcoeffs[i]+mcoeffs[iâŠ•2^j]) else 0)+sum(j+1) else 0;
	return sum(0);
});

def for_(i:!â„•,n:!â„•)[a,b](f: !â„•Ã—aÃ—b!â†’lifted aÃ—b)(x:a,y:b)lifted:aÃ—bâ‡’if i<n then for_(i+1,n)(f)(f(i,x,y)) else (x,y);

def polyPauliRot[a:qtype](rot: !â„Ã—a!â†’mfree a)[d:!â„•](coeffs:!â„^(d+1))[n:!â„•](const state:ğ”¹^n,target:a)mfree{
	mcoeffs:=vector(2^n,0);
	mcoeffs[0]=1;
	rotation_coeffs:=vector(2^n,0);
	(rotation_coeffs,mcoeffs)
	=for_(0,d+1)((i:!â„•,rotation_coeffs:!â„^(2^n),mcoeffs:!â„•^(2^n))qfree{
		nrotation_coeffs:=mkvec(2^n)((j:!â„•)qfreeâ‡’rotation_coeffs[j]+coeffs[i]*mcoeffs[j]);
		if i<d { ncoeffs:=nextCoeffs(mcoeffs); }
		else{ ncoeffs:=mcoeffs; }
		return (nrotation_coeffs,ncoeffs);
	})(rotation_coeffs,mcoeffs);
	//print(rotation_coeffs);
	//__show(__query("type",k));
	__show(__query("type",rotation_coeffs));
	for i in 0..2^n{
		if rotation_coeffs[i]!=0{
			mask:=i as !uint[n];
			def rec(const state:ğ”¹^n,const mask:!uint[n],j:!â„•,target:a)mfree:aâ‡’
				if nâ‰¤j then rot(rotation_coeffs[i],target)
				else if mask[j] then if state[j] then rec(state,mask,j+1,target) else target
				else rec(state,mask,j+1,target);
			target:=rec(state,mask,0,target);
		}
	}
	return target;
}

def main(){
	return polyPauliRot(rotY)[3](1,2,3,4)(3 as uint[5] as ğ”¹^5,1:ğ”¹);
}
+/

// def mkvec(n:!â„•)[a:ctype](f:!â„•!â†’qfree a)qfree:a^n â‡’ if n=0 then () coerce a^n else mkvec(n sub 1)(f)~(f(n sub 1),); // TODO
//def mkvec(n:!â„•)[a](f:!â„•!â†’qfree a)qfree:a^n â‡’ if n=0 then () coerce a^n else mkvec(n sub 1)(f)~(f(n sub 1),); // TODO
/+
def nextCoeffs[n:!â„•](mcoeffs:!â„•^(2^n))qfree{
	nmcoeffs:=vector(2^n,0);
	for i in 0..2^n{
		mask:=i as uint[n];
		for j in 0..n{
			if mask[j]{ // note: this is quantum control
				nmcoeffs[i]+=2^jÂ·(mcoeffs[i]+mcoeffs[iâŠ•2^j]); // TODO: error
			}
		}
	}
	return nmcoeffs;
}
+/

/+
def sum[n:!â„•](weights:!â„•^n)qfree:!â„• â‡’ if n=0 then 0 else weights[0]+sum(weights[1..n]);
def logâ‚‚(x:!â„)qfreeâ‡’log(x)/log(2);
def num_sum_bits[n:!â„•](weights:!â„•^n)qfree: !â„• â‡’ if sum(weights)>0 then floor(logâ‚‚(sum(weights)))+1 coerce !â„• else 1;
def weightedAdder[n:!â„•](weights:!â„•^n):uint[num_sum_bits(weights)]{ return 0:uint[num_sum_bits(weights)]; } // crash
+/

/+
def linearRotY[n:!â„•](slope:!â„,offset:!â„,const q:ğ”¹^n,target:ğ”¹){
	target:=rotY(offset,target);
	def rec(const q:ğ”¹^n,target:ğ”¹,i:!â„•){ // (crash)
		if i<n{
			if q[i]{ target:=rotY(slopeÂ·2^i,target); }
			return rec(q,target,i+1);
		}else{
			return target;
		}
	}
	return rec(q,target,0);
}
+/
/+
def makeIntegerComparator(value:!â„¤,geq:!ğ”¹)[n:!â„•](const state:ğ”¹^n,compare:ğ”¹):ğ”¹{
	if valueâ‰¤0{
		if geq{ compare:=X(compare); }
	}else if value<2^n{
		if n>1{
			twos:=2^n-value as !uint[n];
			//def rec[n:!â„•](const state:ğ”¹^n,compare:ğ”¹,i:!â„•,const r:ğ”¹):ğ”¹{ // TODO: shadowing n should work
			def rec(const state:ğ”¹^n,compare:ğ”¹,i:!â„•,const r:ğ”¹):ğ”¹{
				if i<n-1{
					nr:=if twos[i] then state[i]âˆ¨r else state[i]âˆ§r;
					return rec(state,compare,i+1,nr);
				}else{
					compareâŠ•=if twos[i] then state[i]âˆ¨r else state[i]âˆ§r;
					return compare;
				}
			}
			compare:=rec(state,compare,1,twos[0]âˆ§state[0]);
			if !geq{ compare:=X(compare); }
		}else{
			compareâŠ•=state[0];
			if !geq{ compare:=X(compare); }
		}
	}else{
		if !geq{ compare:=X(compare); }
	}
	return compare;
}
+/

/+
def f[n:!â„•](x:uint[n])mfreeâ‡’x;
def main(){
	n:=1;
	r:=reverse(f[n])(0:uint[n]); // TODO
	return measure(r) as !â„¤;
}
+/

/+
def main() {
	forget(2+2=5);
}
+/

/+
def main(){
	x:=1/2;
	return x|x; // TODO: error
}
+/

/+
def main(){
	x:=0:ğ”¹;
	y:=0:ğ”¹;
	(x,y)[0]=0:ğ”¹; // TODO: error
}
+/
/+
def main(){
	x:=vector(10,0:ğ”¹);
	(x[0],x[1])[0]=1:ğ”¹; // TODO: error
}
+/
/+
+/
/+
def main(){
	[1,2]:=[1,2,3]; // TODO: error
}
+/

/+
def foo[n:!â„•, rr:!â„•](
	const r:!â„•,
	const ee:(ğ”¹^rr)^rr,
)mfree{
	rbar := max(2 * r div 3, 1) coerce !â„•;
	rrbar := 2^rbar;

	tau := vector(rrbar,0:int[r]);
	for i in [0..rrbar){ for j in [0..r){ tau[i][j]:=H(tau[i][j]); } }
	eew := vector(rrbar,false):B^rrbar;
	for i in [0..rrbar){ eew[i]:=H(eew[i]); }

	// snippet from Figure 2
	cTri := 0:int[rrbar];
	for j in [0..rrbar) {
		for k in [j+1..rrbar) {
			if ee[tau[j]][tau[k]] && eew[j] && eew[k] { // crash
				cTri += 1;
	}	}	}
    // ---------------------
	return (tau as int[r][], eew as ğ”¹[], cTri as ğ”¹[]);
}

def main(){
	return foo[2,2](2,vector(2,vector(2,true)));
}
+/

/+
def main(){
	a:=[]:â„•[]; // TODO: error here?
	a~=[1];
}
+/

//def foo[n:!ğ”¹]()â‡’vector(n,0:ğ”¹);

/+
def main(){
	n:=200; // TODO: make running time scale linearly in n!
	a:=vector(n,1:ğ”¹);
	r:=0:int[32];
	def index(a: ğ”¹^n,i:!â„•)lifted{
		return a[i];
	}
	for i in [0..n){
		r+=a[i];
		r+=index(a,i);
	}
	return r;
}
+/

/+
def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	while(measure(H(0:ğ”¹))){
		forget(y);
		y:=dup(x); // TODO
	}
	return H(x);
}
+/


/+
def arcsin(q:!â„) lifted :!â„;
def sqrt(q:!â„) lifted :!â„;

def WState[n:!N](q0:ğ”¹,q1s:ğ”¹^n)mfree:ğ”¹Ã—ğ”¹^n {
    if n+1==1{
        q0 := X(q0);
    } else {
        theta := arcsin(1.0 / sqrt(n));
        q0 := rotY(2*theta, q0);

        if !q0{
            (q1s[0], q1s[1..n]) := WState[n-1](q1s[0], q1s[1..n]); // TODO
        }
    }
    return (q0, q1s)
}
+/

/+
def arcsin(q:!â„) lifted :!â„;
def sqrt(q:!â„) lifted :!â„;

def WState[n:!N](q0:ğ”¹,q1s:ğ”¹^n)mfree:ğ”¹Ã—ğ”¹^n {
    if n+1==1{
        q0 := X(q0);
    } else {
        theta := arcsin(1.0 / sqrt(n));
        q0 := rotY(2*theta, q0);

        if !q0{
            (q1s[0], q1s[1..n]) := WState[n sub 1](q1s[0], q1s[1..n]); // TODO
        }
    }
    return (q0, q1s)
}
+/

/+
def arcsin(q:!â„) lifted :!â„;
def sqrt(q:!â„) lifted :!â„;

def WState[n:!N](q0:ğ”¹,q1s:ğ”¹^n)mfree:ğ”¹Ã—ğ”¹^n {
    if n+1==1{
        q0 := X(q0);
    } else {
        theta := arcsin(1.0 / sqrt(n));
        q0 := rotY(2*theta, q0);

        if !q0{
            (q1s[0], q1s[1..n]) := WState[n-1 coerce !â„•](q1s[0], q1s[1..n]); // TODO
        }
    }
    return (q0, q1s)
}
+/


