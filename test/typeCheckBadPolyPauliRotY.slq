
def polyPauliRotY[d:!‚Ñï](coeffs:!‚Ñù^(d+1))[n:!‚Ñï](const state:ùîπ^n,target:a)mfree{ // error
	rotation_coeffs:=vector(2^n,0:!‚Ñù);
	rotation_coeffs=for2_(0,d+1)((i:!‚Ñï,rotation_coeffs:!‚Ñù^(2^n),mcoeffs:!‚Ñï^(2^n))qfree{
		nrotation_coeffs:=mkvec(2^n)((j:!‚Ñï)qfree‚áírotation_coeffs[j]+coeffs[i]*mcoeffs[j]);
		if i<d { ncoeffs:=nextCoeffs(mcoeffs); }
		else{ ncoeffs:=mcoeffs; }
		return (nrotation_coeffs,ncoeffs);
	})(rotation_coeffs,mkvec(2^n)((i:!‚Ñï)qfree‚áí(i=0):!‚Ñï))[0];
	target:=for_(0,2^n)((i:!‚Ñï,const state:ùîπ^n,target:ùîπ)mfree{
		if rotation_coeffs[i]!=0{
			mask:=i as !uint[n] as !ùîπ^n;
			def rec(const state:ùîπ^n,const mask:!ùîπ^n,j:!‚Ñï,target:a)mfree:a‚áí
				if n‚â§j then rotY(rotation_coeffs[i],target)
				else if mask[j] then if state[j] then rec(state,mask,j+1,target) else target
				else rec(state,mask,j+1,target);
			target:=rec(state,mask,0,target);
		}
		return target
	})(state,target);
	return target;
}
