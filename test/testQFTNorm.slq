// args: --run

/+
def QFT[n:!â„•](Ïˆ: uint[n])mfree: uint[n]{
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	for k in [0..n){
		Ïˆ[k] := H(Ïˆ[k]);
		for l in [k+1..n){
			if Ïˆ[l] && Ïˆ[k]{
				phase(2Â·Ï€Â·2^(k-l-1));
			}
		}
	}
	return Ïˆ;
}
+/

def seq[a,b,c,d](f: !(Î [Ï„]lifted. aÃ—const dÃ—(bÃ—const d!â†’mfree Ï„)!â†’mfree Ï„),g: !(Î [Ï„]lifted. bÃ—const dÃ—(cÃ—const d!â†’mfree Ï„)!â†’mfree Ï„))[Ï„](x:a,const k:d,ret:cÃ—const d!â†’mfree Ï„)mfreeâ‡’f[Ï„](x,k,(y:b,const k:d)mfreeâ‡’g[Ï„](y,k,ret));

def QFT_norm[n:!â„•]()mfree{
	f:=[Ï„](Ïˆ: uint[n], const d:ğŸ™, ret: uint[n]Ã—const ğŸ™!â†’mfree Ï„)mfreeâ‡’ret(Ïˆ,d);
	for k in [0..n div 2){
		f=seq[uint[n],uint[n],uint[n],ğŸ™](f,[Ï„](Ïˆ: uint[n], const d:ğŸ™, ret: uint[n]Ã—const ğŸ™!â†’mfree Ï„)mfree{ (Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]); return ret(Ïˆ,d); });
	}
	for k in [0..n){
		f=seq[uint[n],uint[n],uint[n],ğŸ™](f,[Ï„](Ïˆ: uint[n], const d:ğŸ™, ret: uint[n]Ã—const ğŸ™!â†’mfree Ï„)mfree{ Ïˆ[k] := H(Ïˆ[k]); return ret(Ïˆ,d); });
		for l in [k+1..n){
			f=seq[uint[n],uint[n],uint[n],ğŸ™](f,[Ï„](Ïˆ: uint[n], const d:ğŸ™, ret: uint[n]Ã—const ğŸ™!â†’mfree Ï„)mfree{
				if Ïˆ[l] && Ïˆ[k]{
					phase(2Â·Ï€Â·2^(k-l-1));
				}
				return ret(Ïˆ,d);
			});
		}
	}
	f=seq[uint[n],uint[n],uint[n],ğŸ™](f,[Ï„](Ïˆ: uint[n],const d:ğŸ™,ret: uint[n]Ã—const ğŸ™!â†’mfree Ï„)mfreeâ‡’ret(Ïˆ,d));
	return ((),f);
}

def QFT[n:!â„•](Ïˆ: uint[n])mfree: uint[n]{
	return QFT_norm[n]()[1][uint[n]](Ïˆ,(),(Ïˆ: uint[n],const d:ğŸ™)mfreeâ‡’Ïˆ);
}

def iQFT[n:!â„•](Ïˆ: uint[n])mfree: uint[n]{
	for kr in [0..n){
		k:=n sub 1 sub kr;
		for l in [k+1..n){
			if Ïˆ[l] && Ïˆ[k]{
				phase(-2Â·Ï€Â·2^(k-l-1));
			}
		}
		Ïˆ[k] := H(Ïˆ[k]);
	}
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	return Ïˆ;
}

/+
def phaseQ[n:!â„•](const Ï†: uint[n])mfree{
	for i in [0..n){ if Ï†[i]{ phase(2Â·Ï€Â·2^i/2^n); } }
}
def QFT[n:!â„•](Ïˆ: uint[n])mfree: uint[n]{
	for k in [0..n){
		j:=n sub 1 sub k;
		Ïˆ[j] := H(Ïˆ[j]); // Ïˆ'[j] = 1/âˆš2(|0âŸ©+expi(2Ï€Â·2^kÂ·(Ïˆ&2^j)/2^n)|1âŸ©)
		if Ïˆ[j]{ phaseQ(2^kÂ·(ÏˆâŠ•2^j)); }// Ïˆ''[j] = 1/âˆš2(|0âŸ©+expi(2Ï€Â·2^kÂ·Ïˆ/2^n)|1âŸ©)
	}
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	return Ïˆ;
}
+/
/+
def phaseQ[n:!â„•](const Ï†: uint[n])mfree{
	for i in [0..n){ if (Ï†&2^i)!=0{ phase(2Â·Ï€Â·2^(i-n)); } }
}
def QFT[n:!â„•](Ïˆ: uint[n])mfree: uint[n]{
	for k in [0..n){
		j:=n sub 1 sub k;
		Ïˆ[j] := H(Ïˆ[j]);
		if (Ïˆ&2^j)!=0{ phaseQ(2^k*ÏˆâŠ•2^(n sub 1)); }
	}
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	return Ïˆ;
}
+/

def main(){
	n:=8;
	/+x:=0:uint[n];
	for i in [0..n){ x[i]:=H(x[i]); }
	def f(x:uint[n])liftedâ‡’x%5;
	measure(f(x));
	return (measure(iQFT(x)) as !â„•)/2^n+0.0;+/
		//x[1]:=H(x[1]);
	x:=measure(H(false),H(false),H(false),H(false));
	//forget(iQFT(QFT(x as uint[4]))=x as uint[4]); // TODO
	//r:=iQFT(QFT(x as uint[4]));
	r:=([n:!â„•]â‡’reverse(QFT[n]))(QFT(x as uint[4]));
	// forget((x as uint[4])=r);
	//return measure(x as uint[4])==measure(r);
	assert(measure((x as uint[4])==r));
	return (x as uint[4],r);
	//x[1]:=H(x[1]);
	//return x;
}
