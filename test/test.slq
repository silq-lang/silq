// skipped

/+
// TODO: this fails if we comment out prelude before `def I`
// implicitDup23_9.slq
def main() {
    x := H(0);
    y := !x;
    z := y;
    a := z;
    x := H(x);
    b := !z; /// error
    return (x, z); /// error
}
+/

/+
// implicitDup23_4.slq
def main(){
	x := H(0);
	y := dup(x);
	z := y;
	if y {}
	if y {}
	x := H(x);
	t := y; /// TODO error
	return (x,t);
}
+/

/+
// implicitDup23_3.slq
def main(){
	x := H(0);
	y := dup(x);
	z := y;
	if y {}
	x := H(x);
	t := y; /// TODO error
	return (x,t);
}
+/

/+
def main(){
	a:=[1,2,3];
	i:=0,j:=1;
	a[i]=a[j]; /// TODO
	a[i]âŠ•=a[j]; /// TODO
}
+/

/+
def map(a:type,b:type)[f:aâ†’b][n:!â„•](xs:a^n){
	ys:=();
	//for x in xs{ ys~=f(x); } // TODO
	for i in 0..n{
		[x]~xs:=xs;
		ys~=[f(x)];
	}
	():=xs;
	// return ys; // TODO: ys: b^n
	return ys coerce b^n;
}

// mapH:=map[H]; // TODO
// def mapH[n:!â„•](xs:B^n)=>map[H](xs); // TODO

def mapH[n:!â„•](xs:B^n)=>map(B,B)[H](xs);

def zeros(n:!â„•)â‡’vector(n,0);

def main(){
	(k,b):=mapH(zeros(2));
	a:=dup(k);
	c:=X(dup(a)) xorb b;
	X(a) xorb b := c;
	return (k,b);
}
+/

/+
// forgetCoerce2.slq variant
def main(){
	qs:=(H(0:ğ”¹),H(0:ğ”¹)) coerce ğ”¹^2;
	head:=dup(qs[0]);
	tail:=dup(qs:ğ”¹[])[1..2] coerce ğ”¹^(2 sub 1);
	forget(qs=[head]~(tail:ğ”¹[]) coerce ğ”¹^2);
	qs:=[head]~(tail:ğ”¹[]) coerce ğ”¹^2;
	(qsâ‚€,qsâ‚):=qs;
	(qsâ‚€,qsâ‚):=(H(qsâ‚€),H(qsâ‚));
	assert(measure(qsâ‚€=0&qsâ‚=0)); /// TODO
	return (qsâ‚€,qsâ‚);
}
+/

/+
// forgetCoerce5.slq variant
def main(){
	qs:=(H(0:ğ”¹),H(0:ğ”¹)) coerce ğ”¹^2;
	head:=dup(qs[0]);
	tail:=dup(qs:ğ”¹[])[1..2] coerce ğ”¹^(2 sub 1);
	ws:=dup([head]~(tail:ğ”¹[])) coerce B^2;
	forget(qs=ws);
	forget([head]~(tail:ğ”¹[])=ws:ğ”¹[]);
	(wsâ‚€,wsâ‚):=ws;
	(wsâ‚€,wsâ‚):=(H(wsâ‚€),H(wsâ‚));
	assert(measure(wsâ‚€=0&wsâ‚=0));
	return (wsâ‚€,wsâ‚);
}
+/

/+
// forgetCoerce4.slq variant
def main(){
	qs:=(H(0:ğ”¹),H(0:ğ”¹)) coerce ğ”¹^2;
	head:=dup(qs[0]);
	tail:=dup(qs:ğ”¹[])[1..2] coerce ğ”¹^(2 sub 1);
	forget(qs=dup([head]~(tail:ğ”¹[])) coerce ğ”¹^2);
	(tail,):=tail coerce ğ”¹^1;
	(head,tail):=(H(head),H(tail));
	assert(measure(head=0&tail=0));
	return (head,tail);
}
+/

/+
// forgetCoerce3.slq variant
def main(){
	qs:=(H(0:ğ”¹),H(0:ğ”¹)) coerce ğ”¹^2;
	head:=dup(qs[0]);
	tail:=dup((qs:ğ”¹[])[1..2]) coerce ğ”¹^(2 sub 1);
	forget(qs=[head]~(tail:ğ”¹[]) coerce ğ”¹^2);
	(tail,):=tail coerce ğ”¹^1;
	(head,tail):=(H(head),H(tail));
	assert(measure(head=0&tail=0));
	return (head,tail);
}
+/


/+
def foo(x:ğ”¹){ assert(0); }
def bar(x:ğ”¹)â‡’assert(0); // TODO
def baz(x:ğ”¹)â‡’foo(0); // TODO
+/

/+
def main(){
	x:=H(0);
	y:=dup(x);
	k:=(y,dup(y),dup(y),x);
	return (k,y); /// TODO error
}
+/

/+
// args: --run

def toW[n:!â„•]lifted:ğ”¹^n â†’mfree ğ”¹^nâ‡’lambda(qs:ğ”¹^n)mfree:ğ”¹^n{
	if n==1{ qs[0]:=X(qs[0]); }
	else if n>1{
		Î¸:=asin(1/sqrt(n));
		(([head] coerce ğ”¹^1):ğ”¹[])~((tail coerce ğ”¹^(n sub 1)):ğ”¹[]):=(qs:ğ”¹[]);
		head:=rotY(Î¸,head);
		if !head { tail := toW(tail); }
		qs:=[head]~(tail:ğ”¹[]) coerce B^n;
	}
	return qs;
};

def fromW[n:!â„•]lifted:ğ”¹^nâ†’mfree ğ”¹^nâ‡’lambda(qs:ğ”¹^n)mfree:ğ”¹^n{
    if n = 1 {
        qs[0] := reverse(X)(qs[0]);
    } else if n > 1 {
        Î¸ := asin(1 / sqrt(n));
        __tmp2 := qs coerce ğ”¹[];
        (head,) := dup(__tmp2[0..1]) coerce ğ”¹^1;
        tail := dup(__tmp2[1..__tmp2.length]) coerce ğ”¹^((n sub 1));
        forget(__tmp2=[head] ~ (tail: ğ”¹[])); // crash
        if Â¬head {
            tail := fromW(tail);
        }
        head := reverse(rotY)(Î¸,head);
        __tmp0 := dup((([head] coerce ğ”¹ ^ 1): ğ”¹[]) ~ ((tail coerce ğ”¹ ^ (n sub 1)): ğ”¹[]));
        forget(tail=(__tmp0[1..__tmp0.length]: ğ”¹[]) coerce ğ”¹ ^ (n sub 1));
        forget((head,)=(__tmp0[0..1]: ğ”¹[]) coerce ğ”¹ ^ 1);
        qs := __tmp0 coerce ğ”¹^n;
    }
    return qs;
};

def solve(qs:ğ”¹^3):!ğ”¹{
	if qs[1]{ phase(-2Â·Ï€/3); }
	if qs[2]{ phase(-4Â·Ï€/3); }
	qs:=fromW(qs);
 	return measure(qs as int[3])!=0;
}
def main(){
	qs:=toW(vector(3,0:ğ”¹));
	if qs[1]{ phase(2Â·Ï€/3); }
	if qs[2]{ phase(4Â·Ï€/3); }
	assert(!solve(qs));
}
+/


/+
def main(){
	x:=H(0);
	y:=dup(x);
	z:=y;
	// __show(__query("dep",y)); // TODO: should not change semantics
	measure(x);
	return (y,z); /// error
}
+/

/+
def main(){
	x:=H(0);
	y:=dup(x);
	k:=(y,dup(y),dup(y),x);
	return (k,y); /// TODO error
}
+/

/+
def estimatePhase[n:!â„•][a:qtype](const f: Pi[nrep: !â„•]qfree. a ->mfree a, arg: a)mfree: uint[n] x a{
	x_tilde := 0: uint[n];
	for i in 0..n {
		bit := H(0);
		if bit {
	        nrep := 2^(n sub 1 sub i);
			arg := f[nrep](arg);
			phaseU(nrep * -x_tilde);
		}
		(x_tilde[i], 0) := (H(bit), x_tilde[i]);
	}
	return (x_tilde, arg);
}

def phaseU[n: !N](const x: uint[n]) {
	for i in 0..n {
		if x[i] {
			phase(2*pi * 2^i/2^n);
		}
	}
}

n := 3;
def main() {
	def f[nrep:!N](x: uint[n]){
		x += nrep;
		return x;
	}
	x := 0 as uint[n];
	(x_tilde, x) := estimatePhase[n](f, x);
	return (x_tilde, x);
}
+/

/+
n := 16;
def estimatePhase(const f: unit ->mfree unit): !uint[n] {
	x_tilde := 0: !uint[n];
	for i in 0..n {
		bit := H(0);
		if bit {
	        nrep := 2^(n sub 1 sub i);
			repeat nrep { f(); }
			phaseU(nrep * -x_tilde);
		}
		bit := H(bit);
		x_tilde[i] = measure(bit);
	}
	return x_tilde;
}

def main() {
	for i in 0..10 { // run multiple tests
		x := randomBitvector(n) as !uint[n]; // generate a random phase to estimate
		def f() { phaseU(x); }
		x_tilde := estimatePhase(f);
		print(x_tilde, x);
		assert(x_tilde == x);
	}
}

def randomBitvector(n: !N) {
    x := ();
    for i in 0..n {
	    x ~= [measure(H(0))];
	}
	return x coerce _^n; // (convert from !B[] to !B^n)
}

def phaseU[n: !N](const x: !uint[n]) {
	phase(2*pi * (x as !â„•)/2^n);
}
+/

/+
def phaseU[n: !N](const x: !uint[n]) {
	phase(2*pi * (x as !â„•)/2^n);
}

def main() {
	x := (H(0), H(0)) as uint[2];
	if x[0] { phaseU(2^0 as !uint[2]); }
	if x[1] { phaseU(2^1 as !uint[2]); }
	return x;
}
+/

/+
def phaseU[n:!N](const x:uint[n]){
	for i in 0..n{
		if x[i] {
		    phase(2*pi*2^i/2^n);
		}
	}
}

def main() {
	x := (H(0),H(0)) as uint[2];
	phaseU(x);
	return x;
}
+/

/+
def f(n:!â„•,y:B)â‡’(vector(n,0),y);

def main(){
	xs:=vector(3,0:!B);
	(vector(2,0):_^2)~xs:=xs;
	y:=H(0);
	//f[3](xs,y):=y;
	//f(3,y):=(xs,y);
	return (xs,y);
}
+/
/+
def walk[n:!â„•](qs:ğ”¹^n,m:!â„•,const f:ğ”¹^n â†’ mfree ğ”¹^n) mfree{
    z := 0:ğ”¹;
    for i in [0..m){
        z |= qs[i]==0;
    }
    if z{phase(Ï€);}
    forget(z);
    qs := reverse(f)(qs);
    //f(qs) := qs;
    z := 0:ğ”¹;
    for i in [0..m){
        z |= qs[i]==0;
    }
    if z=0{phase(Ï€);}
    forget(z);
    qs := f(qs);
    return qs;
}
def amplitude_amplification[n:!â„•](qs:ğ”¹^n,m:!â„•,const f:ğ”¹^n â†’ mfree ğ”¹^n){
    nIterations:=floor(Ï€/(4Â·asin(2^(-n/2)))-1);
    for k in [0..nIterations){
        qs := walk(qs,m,f);
    }
    return qs;
}
def cnot(const x:ğ”¹,y:ğ”¹):ğ”¹{
  if x{
    y := X(y);
  }
  return y;
}
def gate(qs:ğ”¹^3) mfree{
    qs[0] := rotY(Ï€/3,qs[0]);
    qs[2] := rotY(Ï€/3,qs[2]);
    qs[1] := cnot(qs[0],qs[1]);
    qs[0] := X(qs[0]);
    qs[2] := cnot(qs[1],qs[2]);
    return qs;
}
def main(){
    qs := 0:uint[3] as ğ”¹^3;
    m := 1:!â„•;
    qs := gate(qs);
    qs := amplitude_amplification(qs,m,gate);
    return qs;
}
+/
/+
def main(){
	x:=(H(0),H(0));
}
+/


/+
def main(){
	x:=H(0);
	y:=dup(x);
	(x,y):=(H(x),H(y));
	return (x,y);
}
+/

/+
def main(){
	x:=(0,1);
	y:=x[1];
	z:=(0,H(1));
	w:=z[1]; /// error
	return (x,y,z,w);
}
+/

/+
def foo[a](x:a)=>x;

def main(){
	//__show(typeof([x:*]â‡’1));
	//__show([*]->2);
	__show(typeof(foo));
}
+/

/+
def main(){
	x := (1, 2); // !B x !N
	x[0] += 1; // !N x !N
	__show(typeof(x));
}
+/


/+
def main(){
	x:=H(0);
	y:=dup(x);
	return (y,x,y); /// TODO ?
}
+/

/+
def foo(n:!â„•){
	while true{
		d:=n;
		if dâ‰ 1{ return; }
	}
}
+/

/+
def bar(n:!â„•){
	d:=n;
	if dâ‰ 1{ return; }
	k:=n;
}
+/

/+
def baz(n:!â„•){
	d:=n;
	if dâ‰ 1{ return; }
}
+/

/+
// liftedConsuming2.slq
def main(){
	x:=H(0);
	y:=dup(x);
	if X(y){ /// error
		return x;
	}
	return X(x);
}
+/

/+
// liftedConsuming8.slq
def main(){
	x:=H(0);
	y:=dup(x);
	if X(y){ /// error
		forget(y); /// error
		return x;
	}else{
		forget(y); /// error
		return x;
	}
}
+/

/+
def hâ‚‚[n:!â„•](x:ğ”¹^n,y:ğ”¹^n)mfreeâ‡’(x,y);
/+
def revhâ‚‚[n:!â„•](const __tmp1391: ğŸ™,moved __tmp1393: (ğ”¹^n)^2)mfree{
    __tmp1394 := reverse(dup(hâ‚‚)[n])(__tmp1393);
    (arg_x,arg_y) := __tmp1394;
    __tmp1392 := (arg_x,arg_y);
    return __tmp1392 coerce (ğ”¹^n)^2;
}
+/

def main(){
	x:=(0:ğ”¹,);
	y:=(1:ğ”¹,);
	z:=(0:ğ”¹,);
	w:=(1:ğ”¹,);
	hâ‚‚[1](x,y):=(y,x);
	//(x,y):=revhâ‚‚[1]((),(y,x));
	return ((x,y),(z,w));
}
+/

/+
def main()â‡’reverse(rotZ)(Ï€,0);
+/

/+
def main(){
	g:=(x:ğ”¹)â‡’x;
	f:=reverse(g);
}
+/

/+
// expand3.slq
def expand[n: !â„•](x: uint[n]) qfree: uint[2*n] {
    vâ‚€ := 0 as uint[n];
    return ((x as ğ”¹^n) ~ (dup(vâ‚€) as ğ”¹^n)) as uint[2*n];
}


def main() {
    a := 1: uint[1];
    q := H(0: ğ”¹);
    if q {
        expand[1](a) := expand[1](a);
    }
    q := H(q);
    measure(q);
    return a;
}
+/


/+
def cmp(const __tmp2: ğ”¹^2,const __tmp3: !ğ”¹^2)qfree{
    __tmp4 := 0;
    __tmp5 := 0;
    if Â¬__tmp4 {
        if 2 â‰  2 {
            __tmp4 â† 1;
            __tmp5 â† 0;
        }
    }
    if Â¬__tmp4 {
        for __tmp6 in [0..2){
            if Â¬__tmp4 {
                if __tmp2[__tmp6] â‰  __tmp3[__tmp6] {
                    __tmp4 â† 1;
                    __tmp5 â† 0;
                }
            }
        }
    }
    if Â¬__tmp4 {
        __tmp4 â† 1;
        __tmp5 â† 1;
    }
    return dup(__tmp5);
}+/

/+
+/

/+
def applyMoved[a:qtype,b:qtype](const f:moved a!â†’mfree b,x:a)mfreeâ‡’f(x);
def applyConst[a:qtype,b:qtype](const f:const a!â†’mfree b,const x:a)mfreeâ‡’f(x);

def main(){
	x:=H(0);
	if x{
		phase(Ï€/2);
		applyMoved(()â‡’(),phase(Ï€/2)):=();
	}
	forget(H(x)=0);
	x:=H(0);
	if x{
		phase(Ï€/2);
		applyConst(()â‡’(),phase(Ï€/2)):=();
	}
	forget(H(x)=1);
}
+/

/+
def f() qfree: unit {}

def main() {
	x := H(0:B);
	if x {
		f(phase(pi / 2)) := ();
	}
	return x;
}
+/

/+
def main(){
	y:=H(0);
	k:=dup(y);
	x:=k;
	return (x,y);
}
+/
/+
def main(){
	def foo(){}
	__show(typeof(foo));
}
+/
/+
def main(){
	assert(([1],(1,2,3))â‰ ([1],(1,)));
}
+/
/+
def main():!â„•^2{
	x:=vector(3,2);
	return (x[0,1]); // error
}
+/

/+
def a4_HADAMARD_Array[k:!N](q:ğ”¹^k) : ğ”¹^k {
	for j in [0..k) { q[j] := H(q[j]); }
	return q;
}

def a7_Diffuse_Array[k:!N](q:ğ”¹^k) : ğ”¹^k {
	q := a4_HADAMARD_Array(q);
	if q == array(k,false) { phase(Ï€); }
	q := a4_HADAMARD_Array(q);
	return q;
}
+/

/+
def main(){
	n:=0;
	x:=vector(X(n),2);
	forget(n); // error
}
+/
/+
def main(){
	n:=2+measure(H(0));
	k:=vector(n,2);
	return k<k;
}
+/

/+
def foo(a:ğ”¹[]Ã—(!ğ”¹[]Ã—ğ”¹),b:ğ”¹[]Ã—(!ğ”¹[]Ã—ğ”¹))lifted{
	return a=b;
}
+/
/+
def foo(){
	x:=H(0):
	forget(x); // TODO: better error message
	x:=3;
}
+/

/+
def foo(){
	x:=H(0);
	forget(x);
	x:=3;
}
+/

/+
def foo(a:ğ”¹[]Ã—(!ğ”¹[]Ã—ğ”¹),b:ğ”¹[]Ã—(!ğ”¹[]Ã—ğ”¹))lifted{
	done:=0;
	r:=0;
	if !done {
		for i in 0..if a[0].length<b[0].length then a[0].length else b[0].length{
			if !done {
				if a[0][i]â‰ b[0][i]{
					done=true;
					r=a[0][i]<b[0][i];
				}
			}
		}
		if !done{
			if a[0].lengthâ‰ b[0].length{
				done=true;
				r=a[0].length<b[0].length;
			}
		}
	}
	return r;
}
+/

/+
def main(){
	x:=(0,1);
	y:=(1,3);
	return x<y;
}
+/
/+
def main() {
    x := H(0:B);
    y := 1:B;
    y = x && y;
	forget(y);
    return x;
}

def main() {
    x := 0:B;
    y := H(1:B);
    y = x && y;
	forget(y);
    return x;
}
+/

/+
def f2(x: int[32], y: int[32]){
	k := dup(x);
	while measure(H(false)){
		k += y;
	}
	__show(__query("dep",k));
	forget(k);
	return (x,y);
}
+/

/+
def foo[Ï„](x:Ï„):Ï„{
	foo[Ï„](y):=x;
	return y;
}
+/
/+
def bar[Ï„:qtype](x:Ï„){
	y:=reverse(bar[Ï„])(x); // TODO
	return y;
}
+/

/+
def rev[Ï„:*](a:Ï„[])lifted{
	b:=[];
	for i in (a.length..-1..0]{
		b~=[dup(a[i])];
	}
	return b;
}

def main()â‡’rev(1,2,3);
+/

/+
def main(){
	for i in (-10..-10..-9]{
		print(i);
	}
	print(1111);
	for i in [-9..10..-10){
		print(i);
	}
	print(2222);
}
+/
/+
def fill[Ï„](n:!â„•,f:ğŸ™!â†’Ï„):Ï„^nâ‡’if n==0 then ()coerce Ï„^n else fill(n sub 1,f)~(f(),);

def prepareState(n:!â„•){ // prepares n pieces of quantum data, distributed to players
	Ï†:=fill(n,()â‡’(H(0),H(1))); // create a quantum teleportation channel for each player
	for i in (n-1..-1..0]{ // distribute receive ends to make ring topology
		(Ï†[i][1],Ï†[i+1][1]):=(Ï†[i+1][1],Ï†[i][1]);
	}
	dump();
	return Ï†;
}

def main()â‡’prepareState(2);
+/
/+
n:=3;

// generate uniform superposition of |0âŸ©,â€¦,|N-1âŸ©
def uniformSuperposition[n:!â„•](N:!â„•){
	while true {
		x:=0:uint[n];
		for i in 0..n{ for j in 0..n { x[i]:=H(x[i]); } }
		if measure(x<N){ return x; }
		measure(x);
	}
}
+/

/+
def foo(const r:!â„•)mfree{
	tau := vector(r,0:int[r]);
	for i in [0..r){ for j in [0..r){ } }
	return tau;
}
+/

/+
// args: --remove-loops
def uniformSuperposition[n:!â„•](N:!â„•){
	while true {
		x:=0:uint[n];
		for i in 0..n{ x[i]:=H(x[i]); }
		if measure(x<N){ return x; }
		measure(x);
	}
}
+/

/+
def main(){
	x:=2;
	def foo()â‡’x;
}
+/

/+
def foo[n:!â„•](x:!ğ”¹^n)lifted:qtype;

def bar[n:!â„•](x:!ğ”¹^n)lifted:foo[n](x);

def main(){
	if measure(H(0)){
		a:=(0,1,1);
		x:=bar(a);
	}else{
		a:=(1,0);
		x:=bar(a);
	}
	return x;
}
+/

/+
def main(){
	x:=H(0);
	def foo(){
		if measure(H(0)){
			y:=H(x);
		}else{
			y:=H(x);
		}
		return y;
	}
	return x;
}
+/

/+
def foo[n:!â„•](x:ğ”¹^(n+1)){
	return x;
}
def main(){
	foo(vector(3,0));
}
+/

/+
def main(){
	if measure(H(0)){
		x:=never;
	}else{
		x:=unit;
	}
	//__show(typeof(x));
	return x;
}
+/

/+
def main(){
	x:=H(0);
	if x{
		t:=[0];
	}else{
		t:=[0,1];
	}
	return (x,t);
}
+/

/+
def main(){
	x:=0:ğ”¹;
	y:=H(x);
	z:=x;
	return y;
}
+/

/+
def main(){
	n:=10;
	x:=vector(n,[0]);
	x[0][0]:=H(x[0][0]);
	orig:=x[1];
	x:=x:(ğ”¹[])^n;
	//x[1]:=(foo(x[1]);
	return x:ğ”¹[][];
}
+/

/+
def foo(xs: ğ”¹^1){
	xs~=[1,0]:ğ”¹[];
	return xs;
}

def main(){
	n:=10;
	x:=vector(n,[0]);
	x[0][0]:=H(x[0][0]);
	x[1]:=foo(x[1]);
	return x:ğ”¹[][];
}
+/
/+
def main(){
	(a,b,c):=vector(3,ğ”¹);
	__show(aâ†’moved bâ†’c);
}
+/
/+
def promote[a,b](f:ğŸ™â†’ a,g:ğŸ™â†’aâ†’b):ğŸ™â†’b{
	return ()=>g()(f());
}
+/

/+
def main():!ğ”¹{
	//x:=H(0);
	f:=()=>0:ğ”¹;
	return f();
}
+/
/+
def main(){
	def foo(i:â„•,const x_prev:ğ”¹):ğ”¹{
		if i=10{ return x_prev; }
		return foo(i+1,!x_prev);
	}
}
+/

/+
def map[a,b][f: a!â†’qfree b][n:!â„•](xs:a^n)qfree:b^n;
def zip[a,b][n:!â„•](xs:a^n,ys:b^n)qfree:(aÃ—b)^n;
def __eq_t[n:!â„•][Ïƒ:*^n,Ï„:*^n](xs:âˆ Ïƒ, ys:âˆ Ï„,cmps: âˆ map[*^2,*][(a:*,b:*)qfreeâ‡’aÃ—bâ†’qfree ğ”¹](zip[*,*](Ïƒ,Ï„)))lifted:ğ”¹;

def main(){}
+/

/+
def foo(x:!ğ”¹[]){
	x[0]:=H(x[0]);
}

def main(){
	foo(x):=0:ğ”¹;
}
+/

/+
def f(x:B) {
	tmp := 0:B;
	(x, tmp) := (tmp, x);
	return x;
}
def main () {
	x := H(0:B);
	return f(x);
}
+/

/+
def f(const x:ğ”¹)qfreeâ‡’x;
def foo(x:ğ”¹)qfree=>if x { 0:ğ”¹ } else { 1:ğ”¹ };
def bar(const p:ğ”¹)â‡’foo(f(p));
+/

/+
def assign[a:*,b:*](forgettable[y] x:a,y:b){
	forget(x);
	return y;
}

def inPlaceAdd[a:*,b:*,Add[a,b]](x:a,y:b){
	x+=y;
	return x;
}

def main(){
	// ...
	x:=assign(x,y); // x=y
	x:=inPlaceAdd(x,y); //x+=y
}
+/

/+
def main(){
	x:=0:ğ”¹;
	for i in 0..10{
		//__show(__query("dep",x));
		x=!x;
	}
	def foo(i:!â„•,const x_prev:ğ”¹):ğ”¹{
		if i=10{ return x_prev; }
		return foo(i+1,!x_prev);
	}
	return foo(0,x);
}
+/

/+
def main(){
	i:=0;
	def foo(x:!â„•){
		i:=dup(x);
		i+=1;
		if i=10{ return i; }
		return foo(x);
	}
}
+/

/+
def main(){
	x:=H(0);
	y:=measure(x)||true;
}
+/

/+
def main(){
	x:=H(0);
	def f()lifted=>dup(x);
	__show(typeof(f()));
	return x;
}
+/

/+
// from qaoa_maxcut.slq
// Clamp a real into [lo, hi].
def clamp(x:!â„, lo:!â„, hi:!â„):!â„{
	if x < lo { return lo; }
	if x > hi { return hi; }
	return x;
}

// Clamp all angles in a vector into [0, Ï€].
def clamp_angles[p:!â„•](angles:!â„^p):!â„^p{
	for i in 0..p { angles[i] = clamp(angles[i], 0.0, Ï€); } // TODO
	return angles;
}
+/

/+
// from qaoa_maxcut*.slq
def main(){
	n := 3;
	y := [0,1,2]:!â„¤^n; // TODO
}
+/

/+
def main(){
	x:=H(0);
	if x{
		y:=[0]:ğ”¹[]; // TODO: improve error message
	}else{
		y:=[0,1]:ğ”¹[];
	}
	return (x,y);
}
+/

/+
// crash
def main(){
	n:=10;
	cand:=0:uint[n];
	with{
		for i in 0..n{
			cand[i]:=H(cand[i]);
		}
	}do{
		if cand==(0:!uint[n]){ phase(Ï€); }
	}
}
+/

/+
def main(){
	i:=12;
	for i in (i-1)..(i+1){} // TODO
}
+/

/+
// ghz2.slq
def ghz(n:!â„•){
	xs:=[H(0)];
	for i in 0..n sub 1{
		xs~=[dup(xs[i])]; /// TODO
	}
	return xs;
}
def main()â‡’ghz(3);
+/

/+
def main(){
	if measure(H(0)){
		(a,b)
	}else{
		(b,a)
	} := (1,2);
}
+/

/+
def main(){
	if measure(H(0)){
		(a,b)
	}else{
		(b,a)
	} := (1,2);
}
+/

/+
def main(){
	q:=0.123e-10:!Q;
	return q;
}
+/

/+
def main(){
	a := vector(2^50, 0); // a: !B^(2^50)
	a ~= vector(2^50, 2);
	__show(typeof(a));
}
+/

/+
def f(const g: B -> B) {
    return g(H(0));
}

def main() {
    x := H(0);
    def g(y: B) {
        if x {
            y := H(y);
        }
		return y;
    }
	return (f(g), x);
}
+/

/+
def f(const g: const B x B -> B, const x: B) {
    return g(x, H(0));
}

def main() {
    x := H(0);
    def g(const x: B, y: B) {
        if x {
            y := H(y);
        }
		return y;
    }
	return (f(g, x), x);
}
+/

/+
def main(){
	x:=H(0);
	y:=dup(x);
	x:=H(x);
	return (x,y);
}
+/

/+
def main(){
	a := ();    // a: unit
	a ~= [2];   // error
	a ~= (1,2); // error
	a ~= ([1,2],);
	__show(typeof(a));
}
+/
/+
def main(){
	//return 1 : ğ”¹ as !â„¤
	return 1==(2 | 3)==3;
}
+/

/+
def main(){
	x:=1:int[5];
	y:=2:int[5];
	return x<2000;
}
+/
//import qft,test;

//def foo() â†¦ lambda(x:B). x;

/+
def main(){
	__show(typeof(N -> N));
}
+/
/+
def main(){
	x:=0;
	x++;
	return x;
}
+/
/+
def foo(){
	x:=H(0);
	y:=dup(x);
	return (dup(y),x);
}
def main()â‡’foo;
+/

/+
def main(){
	x:=H(0);
	y:=dup(x);
	y:=CNOT(y,y); // CNOT: const B x B !->qfree B
	assert(measure(y)==0);
	return x;
}
+/
/+
def main(){
	x:=H(0);
	y:=dup(x);
	if y {
		forget(y); // error
		x:=H(x);
	}
	return x;
}
+/

/+
def a()=>(0:B): !B;
def b()=>(0:B) as !B;
def c()=>(0:B) coerce !B;
def d()=>(0:B) pun !B;
+/

/+
def f(const c:B,x:B) {
    if c {
        return X(x);
    } else {
        return H(x);
    }
}

def g(x:B) => (f pun const B x B !->qfree B)(1, x);

def main()â‡’g(0);
+/
/+
def main(){
	x:=0:B;
	return x coerce !B;
}
+/


/+
def main(){
	q := H(0);
	c := q = 0;
}
+/

/+
def main(){
	i:=H(0);
	a:=(0,1);
	a[i]:=H(a[i]);
	return (i,a);
}
+/

/+
def foo[x:utype]()â‡’();

def main()â‡’foo[never]();
+/
/+
def foo(){
	x:=H(0:ğ”¹);
	y:=H(1:ğ”¹);
	k:=dup(y);
	for i in 0..10{
		forget(k);
		k:=dup(y);
		if y{
			x:=H(x);
		}
		y:=H(y);
	}
	return (x,y,k);
}
+/

/+
def foo(x:ğ”¹){
	y:=dup(x);
	z:=dup(y);
	if z{
		x:=H(x);
		w:=X(z);
	}else{
		w:=z;
	}
	k:=z; /// error // TODO: deterministic error message
	return (x,w);
}
def main()â‡’foo;
+/

/+
// depTest4.slq
def main(){
	n:=3;
	x:=array(n,0:ğ”¹);
	y:=H(0:ğ”¹);
	x[0]=dup(y); /// TODO
	return y;
}
+/

/+
// implicitDup21_6.slq
def foo(x:ğ”¹){
	y:=dup(x);
	z:=y;
	if X(z){ /// TODO show the error only once
		r:=X(x);
	}else{
		r:=x;
	}
	return r;
}
+/


//def main(n:!â„•)â‡’(n,n);

//def main(n:!â„•)â‡’H(0);

/+
def main(){
	a:=1:ğ”¹,b:=0:ğ”¹,ccc:=1:ğ”¹;
	aâŠ•b:=ccc;
	return ccc;
}
+/

/+
def main(){
	x:=H(1:ğ”¹);
	y:=X(x);
	z:=!y;
	y := let { t:=!z; forget(y) } in t;
}
+/

/+
def foo(){
	x:=H(0);
	f:=()â‡’dup(x);
	k:=f();
	return x;
}
def main()â‡’foo;
+/
/+
def foo(){
	x:=H(0);
	def f()â‡’dup(x); /// TODO
	return x;
}
+/
/+
def foo(){
	x:=H(0);
	y:=0:ğ”¹;
	def foo(){
		foo:=2;
		y:=CNOT(x,y);
		return y;
	}
	forget(foo);
	//__show(__query("dep",foo));
	return x;
}
+/
/+
def foo(f:!Î (x:ğ”¹)moved qfree. ğ”¹){
	__show(typeof(f));
	return f: ğ”¹ once!â†’qfree ğ”¹;
}
+/

/+
def main(n: !â„•){
	a := array(n, 0:ğ”¹);
	a[0]:=H(a[0]);
	f:=()â‡’0;
	a[f()]:=a[f()];
	return a;
}
+/

/+
def egcd(a:!â„¤,b:!â„¤){
	(x,y,u,v):=(a,b,1,0):!â„¤^4;
	while yâ‰ 0{
		(x,y,u,v)=
			(y,x%y,v,u-(x div y)Â·v);
	}
	return (x,u);
}
+/

/+
def main(){
	x:=(0,);
	x[0]:=x[0];
}
+/

/+
def foo(const x:ğ”¹)[Ï„:*](y:Ï„)â‡’y;

def main(){
	x:=H(0);
	return foo(x)(x);
}
+/

/+
def foo(){
	x:=H(0);
	y:=dup(x); // the dup[ğ”¹] should not be trivially let-bound
	z:=dup(y);
	return (x,y,z);
}
def main()â‡’foo;
+/


/+
def main(){
	for i in 0..10{
		print(i);
	}
}
+/

/+
def splitFront[m:!â„•][a:type,n:!â„•](xs:a^n)qfree:a^mÃ—a^(n sub m){
	(anc:a^m)~(xs:a^(n sub m)):=xs;
	return (anc,xs);
}
def dropAncillas[m:!â„•][n:!â„•](xs:ğ”¹^n):!ğ”¹Ã—ğ”¹^(n sub m){
	(anc,xs):=splitFront[m](xs);
	success:=(measure(anc) as !uint[m]) = 0;
	return (success,xs);
}
def main(){
	return dropAncillas[2]([H(0)]~vector(4,0));
}
+/
/+
def main(){
	// Sketchy pseudo-pattern just to illustrate the growth:
	f := lambda(x:!B){ assert(0) } : !B->never;               // start at bottom
	while true {
		// each iteration rebinds f to a closure that *captures* the old f
		f := lambda(x:!B){ return (x, f); };    // f : !B !-> (!B x type(f_prev))
	}
}
+/

/+
def main(){
	x := 3;
	x^=2;
	return x;
}
+/

/+
def main(){ // TODO: this should be fast in frontend simulator
	x:=array(10000,0);
	for i in 0..10000{
		x=x;
	}
	return x;
}
+/

/+
def main(){
	x:=H(0);
	y:=dup(x);
	k:=dup(y);
	z:=y;
	forget(k);
	return (x,z);
}
+/

/+
def main(){
	x:=H(0);
	y:=dup(x);
	if true{
		__show(__query("dep",y));
		forget(y);
		H(0):=x;
	}else{
		assert(0);
	}
}
+/

/+
def main(){
	x:=(0,);
	x[0]:=H(x[0]);
	return x;
}
+/
/+
def main(){
	x:=0:ğ”¹;
	y:=x;
	if measure(H(0)){
		return;
	}else{
		x:=1:ğ”¹;
	}
}
+/

/+
def bar(n:!â„•){
	if nâ‰ 0{
		return n+1;
	}
	return 0:!ğ”¹;
}

def main()â‡’bar;
+/

/+
def foo(x:!ğ”¹){
	return ()qfree:!ğ”¹â‡’x;
}
def main(){
	return foo(0);
}
+/

/+
def foo(x:ğ”¹){
	y:=dup(x);
	z:=H(y);
	w:=H(y); /// TODO error?
	return (x,z,w);
}
+/

/+
def foo(){
	if true{
		x:=0:ğ”¹;
		y:=x;
	}else{
		x:=1:ğ”¹;
		y:=x;
	}
	x:=2;
}
+/
/+
def foo(x:ğ”¹){ assert(0); }
def bar(x:ğ”¹)â‡’assert(0); // TODO
def baz(x:ğ”¹)â‡’foo(0); // TODO
+/

/+
def main(){
	x:=H(0);
	y:=dup(x);
	z:=y;
	// __show(__query("dep",y)); // TODO: should not change semantics
	measure(x);
	return (y,z); /// error
}
+/

/+
def main(){
	x:=H(0);
	y:=dup(x);
	k:=(y,dup(y),dup(y),x); /// TODO ?
	return (k,y);
}
+/

/+
def main(){
	x:=H(0);
	y:=dup(x);
	return (y,x,y); /// TODO ?
}
+/

/+
def foo(n:!â„•){
	while true{
		d:=n;
		if dâ‰ 1{ return; }
	}
}
+/

/+
def bar(n:!â„•){
	d:=n;
	if dâ‰ 1{ return; }
	k:=n;
}
+/

/+
def baz(n:!â„•){
	d:=n;
	if dâ‰ 1{ return; }
}
+/

/+
// liftedConsuming2.slq
def main(){
	x:=H(0);
	y:=dup(x);
	if X(y){ /// error
		return x;
	}
	return X(x);
}
+/

/+
// liftedConsuming8.slq
def main(){
	x:=H(0);
	y:=dup(x);
	if X(y){ /// error
		forget(y); /// error
		return x;
	}else{
		forget(y); /// error
		return x;
	}
}
+/

/+
def hâ‚‚[n:!â„•](x:ğ”¹^n,y:ğ”¹^n)mfreeâ‡’(x,y);
/+
def revhâ‚‚[n:!â„•](const __tmp1391: ğŸ™,moved __tmp1393: (ğ”¹^n)^2)mfree{
    __tmp1394 := reverse(dup(hâ‚‚)[n])(__tmp1393);
    (arg_x,arg_y) := __tmp1394;
    __tmp1392 := (arg_x,arg_y);
    return __tmp1392 coerce (ğ”¹^n)^2;
}
+/

def main(){
	x:=(0:ğ”¹,);
	y:=(1:ğ”¹,);
	z:=(0:ğ”¹,);
	w:=(1:ğ”¹,);
	hâ‚‚[1](x,y):=(y,x);
	//(x,y):=revhâ‚‚[1]((),(y,x));
	return ((x,y),(z,w));
}
+/

/+
def main()â‡’reverse(rotZ)(Ï€,0);
+/

/+
def main(){
	g:=(x:ğ”¹)â‡’x;
	f:=reverse(g);
}
+/

/+
// expand3.slq
def expand[n: !â„•](x: uint[n]) qfree: uint[2*n] {
    vâ‚€ := 0 as uint[n];
    return ((x as ğ”¹^n) ~ (dup(vâ‚€) as ğ”¹^n)) as uint[2*n];
}


def main() {
    a := 1: uint[1];
    q := H(0: ğ”¹);
    if q {
        expand[1](a) := expand[1](a);
    }
    q := H(q);
    measure(q);
    return a;
}
+/


/+
def cmp(const __tmp2: ğ”¹^2,const __tmp3: !ğ”¹^2)qfree{
    __tmp4 := 0;
    __tmp5 := 0;
    if Â¬__tmp4 {
        if 2 â‰  2 {
            __tmp4 â† 1;
            __tmp5 â† 0;
        }
    }
    if Â¬__tmp4 {
        for __tmp6 in [0..2){
            if Â¬__tmp4 {
                if __tmp2[__tmp6] â‰  __tmp3[__tmp6] {
                    __tmp4 â† 1;
                    __tmp5 â† 0;
                }
            }
        }
    }
    if Â¬__tmp4 {
        __tmp4 â† 1;
        __tmp5 â† 1;
    }
    return dup(__tmp5);
}+/

/+
+/

/+
def applyMoved[a:qtype,b:qtype](const f:moved a!â†’mfree b,x:a)mfreeâ‡’f(x);
def applyConst[a:qtype,b:qtype](const f:const a!â†’mfree b,const x:a)mfreeâ‡’f(x);

def main(){
	x:=H(0);
	if x{
		phase(Ï€/2);
		applyMoved(()â‡’(),phase(Ï€/2)):=();
	}
	forget(H(x)=0);
	x:=H(0);
	if x{
		phase(Ï€/2);
		applyConst(()â‡’(),phase(Ï€/2)):=();
	}
	forget(H(x)=1);
}
+/

/+
def f() qfree: unit {}

def main() {
	x := H(0:B);
	if x {
		f(phase(pi / 2)) := ();
	}
	return x;
}
+/

/+
def main(){
	y:=H(0);
	k:=dup(y);
	x:=k;
	return (x,y);
}
+/
/+
def main(){
	def foo(){}
	__show(typeof(foo));
}
+/
/+
def main(){
	assert(([1],(1,2,3))â‰ ([1],(1,)));
}
+/
/+
def main():!â„•^2{
	x:=vector(3,2);
	return (x[0,1]); // error
}
+/

/+
def a4_HADAMARD_Array[k:!N](q:ğ”¹^k) : ğ”¹^k {
	for j in [0..k) { q[j] := H(q[j]); }
	return q;
}

def a7_Diffuse_Array[k:!N](q:ğ”¹^k) : ğ”¹^k {
	q := a4_HADAMARD_Array(q);
	if q == array(k,false) { phase(Ï€); }
	q := a4_HADAMARD_Array(q);
	return q;
}
+/

/+
def main(){
	n:=0;
	x:=vector(X(n),2);
	forget(n); // error
}
+/
/+
def main(){
	n:=2+measure(H(0));
	k:=vector(n,2);
	return k<k;
}
+/

/+
def foo(a:ğ”¹[]Ã—(!ğ”¹[]Ã—ğ”¹),b:ğ”¹[]Ã—(!ğ”¹[]Ã—ğ”¹))lifted{
	return a=b;
}
+/
/+
def foo(){
	x:=H(0):
	forget(x); // TODO: better error message
	x:=3;
}
+/

/+
def foo(){
	x:=H(0);
	forget(x);
	x:=3;
}
+/

/+
def foo(a:ğ”¹[]Ã—(!ğ”¹[]Ã—ğ”¹),b:ğ”¹[]Ã—(!ğ”¹[]Ã—ğ”¹))lifted{
	done:=0;
	r:=0;
	if !done {
		for i in 0..if a[0].length<b[0].length then a[0].length else b[0].length{
			if !done {
				if a[0][i]â‰ b[0][i]{
					done=true;
					r=a[0][i]<b[0][i];
				}
			}
		}
		if !done{
			if a[0].lengthâ‰ b[0].length{
				done=true;
				r=a[0].length<b[0].length;
			}
		}
	}
	return r;
}
+/

/+
def main(){
	x:=(0,1);
	y:=(1,3);
	return x<y;
}
+/
/+
def main() {
    x := H(0:B);
    y := 1:B;
    y = x && y;
	forget(y);
    return x;
}

def main() {
    x := 0:B;
    y := H(1:B);
    y = x && y;
	forget(y);
    return x;
}
+/

/+
def f2(x: int[32], y: int[32]){
	k := dup(x);
	while measure(H(false)){
		k += y;
	}
	__show(__query("dep",k));
	forget(k);
	return (x,y);
}
+/

/+
def foo[Ï„](x:Ï„):Ï„{
	foo[Ï„](y):=x;
	return y;
}
+/
/+
def bar[Ï„:qtype](x:Ï„){
	y:=reverse(bar[Ï„])(x); // TODO
	return y;
}
+/

/+
def rev[Ï„:*](a:Ï„[])lifted{
	b:=[];
	for i in (a.length..-1..0]{
		b~=[dup(a[i])];
	}
	return b;
}

def main()â‡’rev(1,2,3);
+/

/+
def main(){
	for i in (-10..-10..-9]{
		print(i);
	}
	print(1111);
	for i in [-9..10..-10){
		print(i);
	}
	print(2222);
}
+/
/+
def fill[Ï„](n:!â„•,f:ğŸ™!â†’Ï„):Ï„^nâ‡’if n==0 then ()coerce Ï„^n else fill(n sub 1,f)~(f(),);

def prepareState(n:!â„•){ // prepares n pieces of quantum data, distributed to players
	Ï†:=fill(n,()â‡’(H(0),H(1))); // create a quantum teleportation channel for each player
	for i in (n-1..-1..0]{ // distribute receive ends to make ring topology
		(Ï†[i][1],Ï†[i+1][1]):=(Ï†[i+1][1],Ï†[i][1]);
	}
	dump();
	return Ï†;
}

def main()â‡’prepareState(2);
+/
/+
n:=3;

// generate uniform superposition of |0âŸ©,â€¦,|N-1âŸ©
def uniformSuperposition[n:!â„•](N:!â„•){
	while true {
		x:=0:uint[n];
		for i in 0..n{ for j in 0..n { x[i]:=H(x[i]); } }
		if measure(x<N){ return x; }
		measure(x);
	}
}
+/

/+
def foo(const r:!â„•)mfree{
	tau := vector(r,0:int[r]);
	for i in [0..r){ for j in [0..r){ } }
	return tau;
}
+/

/+
// args: --remove-loops
def uniformSuperposition[n:!â„•](N:!â„•){
	while true {
		x:=0:uint[n];
		for i in 0..n{ x[i]:=H(x[i]); }
		if measure(x<N){ return x; }
		measure(x);
	}
}
+/

/+
def main(){
	x:=2;
	def foo()â‡’x;
}
+/

/+
def foo[n:!â„•](x:!ğ”¹^n)lifted:qtype;

def bar[n:!â„•](x:!ğ”¹^n)lifted:foo[n](x);

def main(){
	if measure(H(0)){
		a:=(0,1,1);
		x:=bar(a);
	}else{
		a:=(1,0);
		x:=bar(a);
	}
	return x;
}
+/

/+
def main(){
	x:=H(0);
	def foo(){
		if measure(H(0)){
			y:=H(x);
		}else{
			y:=H(x);
		}
		return y;
	}
	return x;
}
+/

/+
def foo[n:!â„•](x:ğ”¹^(n+1)){
	return x;
}
def main(){
	foo(vector(3,0));
}
+/

/+
def main(){
	if measure(H(0)){
		x:=never;
	}else{
		x:=unit;
	}
	//__show(typeof(x));
	return x;
}
+/

/+
def main(){
	x:=H(0);
	if x{
		t:=[0];
	}else{
		t:=[0,1];
	}
	return (x,t);
}
+/

/+
def main(){
	x:=0:ğ”¹;
	y:=H(x);
	z:=x;
	return y;
}
+/

/+
def main(){
	n:=10;
	x:=vector(n,[0]);
	x[0][0]:=H(x[0][0]);
	orig:=x[1];
	x:=x:(ğ”¹[])^n;
	//x[1]:=(foo(x[1]);
	return x:ğ”¹[][];
}
+/

/+
def foo(xs: ğ”¹^1){
	xs~=[1,0]:ğ”¹[];
	return xs;
}

def main(){
	n:=10;
	x:=vector(n,[0]);
	x[0][0]:=H(x[0][0]);
	x[1]:=foo(x[1]);
	return x:ğ”¹[][];
}
+/
/+
def main(){
	(a,b,c):=vector(3,ğ”¹);
	__show(aâ†’moved bâ†’c);
}
+/
/+
def promote[a,b](f:ğŸ™â†’ a,g:ğŸ™â†’aâ†’b):ğŸ™â†’b{
	return ()=>g()(f());
}
+/

/+
def main():!ğ”¹{
	//x:=H(0);
	f:=()=>0:ğ”¹;
	return f();
}
+/
/+
def main(){
	def foo(i:â„•,const x_prev:ğ”¹):ğ”¹{
		if i=10{ return x_prev; }
		return foo(i+1,!x_prev);
	}
}
+/

/+
def map[a,b][f: a!â†’qfree b][n:!â„•](xs:a^n)qfree:b^n;
def zip[a,b][n:!â„•](xs:a^n,ys:b^n)qfree:(aÃ—b)^n;
def __eq_t[n:!â„•][Ïƒ:*^n,Ï„:*^n](xs:âˆ Ïƒ, ys:âˆ Ï„,cmps: âˆ map[*^2,*][(a:*,b:*)qfreeâ‡’aÃ—bâ†’qfree ğ”¹](zip[*,*](Ïƒ,Ï„)))lifted:ğ”¹;

def main(){}
+/

/+
def foo(x:!ğ”¹[]){
	x[0]:=H(x[0]);
}

def main(){
	foo(x):=0:ğ”¹;
}
+/

/+
def f(x:B) {
	tmp := 0:B;
	(x, tmp) := (tmp, x);
	return x;
}
def main () {
	x := H(0:B);
	return f(x);
}
+/

/+
def f(const x:ğ”¹)qfreeâ‡’x;
def foo(x:ğ”¹)qfree=>if x { 0:ğ”¹ } else { 1:ğ”¹ };
def bar(const p:ğ”¹)â‡’foo(f(p));
+/

/+
def assign[a:*,b:*](forgettable[y] x:a,y:b){
	forget(x);
	return y;
}

def inPlaceAdd[a:*,b:*,Add[a,b]](x:a,y:b){
	x+=y;
	return x;
}

def main(){
	// ...
	x:=assign(x,y); // x=y
	x:=inPlaceAdd(x,y); //x+=y
}
+/

/+
def main(){
	x:=0:ğ”¹;
	for i in 0..10{
		//__show(__query("dep",x));
		x=!x;
	}
	def foo(i:!â„•,const x_prev:ğ”¹):ğ”¹{
		if i=10{ return x_prev; }
		return foo(i+1,!x_prev);
	}
	return foo(0,x);
}
+/

/+
def main(){
	i:=0;
	def foo(x:!â„•){
		i:=dup(x);
		i+=1;
		if i=10{ return i; }
		return foo(x);
	}
}
+/

/+
def main(){
	x:=H(0);
	y:=measure(x)||true;
}
+/

// ---

/+
def main(){
	x:=2;
	if measure(H(0)){
		return 0;
	}else{
		x=3;
	}
	return 1;
}
+/

/+
def main(){
	__show(typeof(if measure(H(0)) then (a:!â„•,b:!â„•)â‡’(vector(a,0),vector(b,0)) else (b:!â„•,a:!â„•)â‡’(vector(b,0),vector(a,0))));
	__show(typeof(if measure(H(0)) then (a:!â„•,b:!â„•)wildâ‡’(vector(a,0),vector(b,0)) else (b:!â„•,a:!â„•)â‡’(vector(b,0),vector(a,0))));
}
+/

/+
def intLtâ‚ƒ[n:!â„•](x:ğ”¹^n,y:ğ”¹^n)lifted:ğ”¹{
    if n=0{ return false; }
	r := intLtâ‚ƒ(x[0..n sub 1],y[0..n sub 1]);
	res := if x[n-1]=y[n-1] then dup(r) else y[n-1];
	intLtâ‚ƒ(assert(0),assert(0)):=r; // TODO: better error message
	return res;
}
+/

/+
+/

/+
def f[n:!â„•](xs:ğ”¹^n)â‡’xs;

def main(){
	//f(xs):=[1,0,1];
	//xs:=reverse(f)([1,0,1]);
	x:=1:ğ”¹;
	1:B:=x;
}
+/

/+
def f(x:ğ”¹):âŠ¥{ assert(0); }

def main(){
	f(x):=2;
	(a,)~f(b):=(1,2);
	return (x,b);
}
+/

/+
def foo():âŠ¥{assert(0);}
def main(){
	foo():=2;
	//foo()~(foo():ğ”¹^2):=2;
}
+/

/+
def main(){
	x:=0:int[assert(0)];
}
+/

/+
def main(){
	x := [0:B,1:B];
	for i in [0..2) {
		if true{
			x[0] := H(x[0]);
		}
	}
	return x;
}
+/
/+
def main(){
	a:=[1,2,3];
	x:=vector(3,0);
	x[a]:=x[a];
}
+/
/+
def main() {
	x := 42:!uint[6];
	x[1] := H(x[1]);
	__show(__query("type", x)); // uint[6]
	return x;
}
+/
/+
def main(){
	x := (0:B, 0:!B, 0:!B);
	x[i] := H(x[i]);
	__show(__query("type", x)); // B^3
}
+/

/+
def main(){
	x:=vector(10, 0:B)[0..4];
	__show(typeof(x));
	y:=array(10, 0:B)[0..4];
	__show(typeof(y));
}
+/

/+
def constUse(const x:ğ”¹){}

def main(){
	x:=H(0); // x â†¦ âŠ¤
	y:=dup(x); // x â†¦ âŠ¤, y â†¦ {x}
	z:=dup(y); // x â†’ âŠ¤, y â†¦ {x}, z â†¦ {y}
	constUse(y); // last use of y
	x:=H(x); // y â†¦ âŠ¤, z â†¦ {y}
	constUse(z); // last use of z
	return x;
}
+/

/+
def foo(x:ğ”¹)mfree{
	def bar(i:!â„•,x:ğ”¹)mfree:ğ”¹{
		if i=0{ r:=x; }
		else { r:= bar(i sub 1,X(x)); }
		return r;
	}
	return bar(11,x);
}
+/

/+
def rfoo(__tmp12:ğ”¹)mfree{
    def bar(moved i: Â¬â„•,moved x: ğ”¹)mfree:ğ”¹{
        if i = 0 {
            r := x;
        } else {
            r := bar(i sub 1,X(x));
        }
        return r;
    }
    bar(10,x) := __tmp12;
    return x coerce ğ”¹;
}

def main(){
	foo(x):=0:ğ”¹;
	//x:=rfoo(0:ğ”¹);
	return x;
}
+/

/+
def foo(p:ğ”¹)qfree{
	q:=0:ğ”¹;
	q:=if p then X(q) else q;
	p:=if q then X(p) else p;
	//forget(q);
	return (p,q);
}
+/

/+
def f(x:ğ”¹){
	return rotY(3Â·Ï€/2,X(x));
	//return rotY(Ï€/2,rotZ(Ï€,x));
}

def main(){
	x := H(0:B);
	y := dup(x);
	y := H(f(y));
	forget(y=x);
	x := H(x);
	forget(x=0);
}
+/

/+
def foo(a:ğ”¹^5)mfree{
	//(u:ğ”¹^2)~(tmp0,)~(v:ğ”¹^1)~(tmp1,)~(w:ğ”¹^0) := a;
	i:=2,j:=4;
	with{
		if true{
			(u:ğ”¹^i)~(tmp0,)~(v:ğ”¹^(j sub (i+1)))~(tmp1,)~(w:ğ”¹^(5 sub (j+1))) := a;
		}else{
			(u:ğ”¹^i)~(tmp0,)~(v:ğ”¹^(j sub (i+1)))~(tmp1,)~(w:ğ”¹^(5 sub (j+1))) := a;
		}
	}do{}
	return (u,tmp0,v,tmp1,w);
}

def main(){
	return reverse(foo);
}
+/

/+
def main(){
	a:=(1,0,1,1,0):ğ”¹^5;
	i:=2,j:=4;
	with{
		if i < j {
			(u:ğ”¹^i)~(tmp0,)~(v:ğ”¹^(j sub (i+1)))~(tmp1,)~(w:ğ”¹^(5 sub (j+1))) := a;
		} else {
			(u:ğ”¹^j)~(tmp0,)~(v:ğ”¹^(i sub (j+1)))~(tmp1,)~(w:ğ”¹^(5 sub (i+1))) := a;
		}
	} do {}//(tmp0,tmp1):=(tmp1,tmp0);
	return a;
}
+/

/+
def foo(p:ğ”¹)qfree{
	q:=0:ğ”¹;
	q:=if p then X(q) else q;
	p:=if q then X(p) else p;
	//forget(q);
	return (p,q);
}
+/

/+
def f(x:ğ”¹){
	return rotY(3Â·Ï€/2,X(x));
	//return rotY(Ï€/2,rotZ(Ï€,x));
}
+/

/+
def main(){
	x := H(0:B);
	y := dup(x);
	y := H(f(y));
	forget(y=x);
	x := H(x);
	forget(x=0);
}
+/

/+
def main(){
	return classical false;
}
+/

/+
def H_n[n:!â„•](xs:ğ”¹^n)mfree: ğ”¹^n {
	if nâ‰ 0 {
		with (h,)~t:=xs do {
			h := H(h);
			t := H_n(t);
		}
	}
	return xs;
}

def maj(x:ğ”¹,y:ğ”¹,z:ğ”¹)lifted => if x=y then y else z;

def dj(){
	xs := (0,0,0): ğ”¹^3;
	with xs := H_n(xs) do {
		if maj(xs) {
			phase(Ï€);
		}
	}
	return measure(xs)â‰ (0,0,0);
}

def main(){
	return dj();
}
+/

/+
def main(){
	xs:=vector(2,vector(2,0:ğ”¹));
	xs[0][1]=1:ğ”¹;
	//ys:=vector(2,0:ğ”¹);
	//(xs[0],xs[0][1]):=(xs[0],xs[0][1]); // error
	//(xs[0][1],xs[0]):=(xs[0][1],xs[0]); // error
	(xs[0][1],xs[1][0],1:ğ”¹):=(xs[1][0],xs[0][1],1:ğ”¹);
	return xs;
}
+/

/+
def main(){
	xs:=vector(2,0:ğ”¹);
	ys:=vector(2,0:ğ”¹);
	(xs[0],xs[1],ys[0],ys[1]):=(xs[0],ys[0],xs[1],ys[1]);
	return (xs,ys);}
+/

/+
def main(){
	(x:ğ”¹^3)~(y:ğ”¹^2):=(0,1,1,0,1):ğ”¹^5;
	return (x,y);
}
+/

/+
def main(){
	x:=H(0:ğ”¹);
	y:=H(dup(x));
	measure(y);
	return x;
}
+/

/+
def foo[n:!â„•](xs:ğ”¹^n)mfree{
	xs[0]:=H(xs[0]);
	return xs;
}

def main(){
	foo(x,):=(0:ğ”¹,);
	return x;
}
+/

/+
def main(){
	xs:=vector(3,0:ğ”¹);
	xs[2]=xs[2]âŠ•(1:ğ”¹);
}
+/

/+
def sqrtmone(): !R {
	return (-1)^(1/2);
}

def main(){
	return sqrtmone();
}
+/

/+
def main(){
	x:=0:ğ”¹;
	_:=x;
	return _;
}
+/

/+
def main(){
	x:=0:Rat;
	x+=2:Nat;
}
+/

/+
def main(){
	t := (2, 3);
	z := t~t~t;
	(a,)~x~(b, c) := z;
	return (a, x, b, c);
}
+/

/+
def main(){
	return 1%0;
}
+/

/+
def main(){
	return 1e-10:!â„¤; // TODO: error
}
+/

/+
def main(){
	//if true then assert(false) else assert(false);
	x:=assert(false);
}
+/

/+
def x[cond:!ğ”¹,t1:*,t2:*](arg:(()qfree=>if cond { t1 } else { t2 })()) {
	return measure(arg); // TODO
}
+/

/+
def main(){
	x:=1:uint[2];
	//y:=true:ğ”¹ coerce uint[2];
	//return x+y;
	//return -2 sub -2;
	//return x^2;
	return -3&-5/2;
}
+/

/+
def pack4(w0: uint[16], w1: uint[16], w2: uint[16], w3: uint[16]) qfree: uint[64] {
	return ((w0 as B^16) ~ (w1 as B^16) ~ (w2 as B^16) ~ (w3 as B^16)) as uint[64];
}

def main() {
	num := 16902157913843545776 as !uint[64];
	pack4(k0, k1, k2, k3) := num;
	return (num, pack4(k0, k1, k2, k3));
}
+/


/+
def foo(const x:ğ”¹){
	__show(__query("dep",x));
}

def main(){
	n:=2+measure(H(0:ğ”¹));
	x:=vector(n,0:ğ”¹);
	for i in 0..n{ x[i]:=H(x[i]); }
}
+/
/+
def main(){
	/+x:=0:ğ”¹;
	y:=H(dup(x));
	z:=dup(y);
	y:=H(y);
	assert(measure(x=y));
	forget(y=x);
	return z;+/
	x:=H(0:ğ”¹);    // |0âŸ©+|1âŸ©
	tmp:=dup(x);  // |00âŸ©+|11âŸ©
	y:=H(tmp);    // |0+âŸ©+|1-âŸ©
		          // = |00âŸ©+|01âŸ©+|10âŸ©-|11âŸ©
	x:=H(x);      // |+0âŸ©+|+1âŸ©+|-0âŸ©-|-1âŸ© = |00âŸ©+|10âŸ©+|01âŸ©-|11âŸ©+|00âŸ©-|10âŸ©-|01âŸ©+|11âŸ©
	              // = |00âŸ©+|11âŸ©
	return (x,y);
}
+/

/+
def main(){
	return -1:int[0];
}
+/

/+
def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	y:=H(y);
	z:=0:ğ”¹;
	if y{
		z:=X(z);
	}
	H(y):=y;
	dump();
	assert(measure(y==x));
	forget(y=x);
	return (x,z);
}
+/

/+
def good(x:uint[8]){
	xt~(xh,):=x as ğ”¹^8;
	x:=(xh,)~xt as uint[8];
	return x;
}

def bad(x:uint[8]){
	tmp:=dup(x);
	tmp+=x;
	(x,tmp):=(tmp,x);
	tt~(th,):=tmp as ğ”¹^8;
	tmp:=(th,)~tt as uint[8];
	tmp-=x;
	forget(tmp=0);
	return x;
}

def main(){
	//return good(129:uint[8]);
	return bad(127:uint[8]);
}
+/

/+
def main(){
	x:=0:uint[1];
	x[0]:=H(x[0]);
	x*=2;
	return x;
}
+/
/+
def foo(){
	x:=();
	x=3;
	x=()=>2;
}
+/

/+
def main(){
	n:=20;
	r:=337;
	x:=floor((1/r)*2^n)/2^n;
	return approx(x,2^n);
	//return candidates(x);
}


def approx_iter(lim: !â„•, v: !â„, p0: !â„•, q0: !â„•, p1: !â„•, q1: !â„•) qfree: !â„• x !â„• {
    k := floor(v) coerce !â„•;
    p2 := k*p1 + p0;
    q2 := k*q1 + q0;
    if p2 > lim || q2 > lim {
        return (p1, q1);
    } else if v - k < 1 / lim {
        return (p2, q2);
    } else {
        return approx_iter(lim, 1 / (v-k), p1, q1, p2, q2);
    }
}

def approx(v: !â„, lim: !â„•) qfree: !â„• x !â„• {
    if v <= 1/lim {
        return (0, 1);
    } else if v >= 1 - 1/lim {
        return (1, 1);
    } else {
        return approx_iter(lim, v, 0, 1, 1, 0);
    }
}
def candidates(q:!â„š){ // // TODO: probably this can be improved
	res:=[]:!â„¤[];
	r:=to_cfrac(q);
	while r.lengthâ‰ 0{
		res~=[from_cfrac(r)[1]];
		r=r[0..r.length-1];
	}
	return res;
}
def to_cfrac(q:!â„š){
	if q=0{ return [0:!â„¤]; }
	r:=[]:!â„¤[];
	nq:=1/q;
	while nqâ‰ 0{
		nq=1/nq;
		p:=floor(nq);
		nq-=p;
		r~=[p];
	}
	return r;
}
def gcdn(a:!â„•,b:!â„•):!â„•â‡’gcd(a,b) coerce !â„•;
def gcd(a:!â„¤,b:!â„¤):!â„¤â‡’if a=0 then b else gcd(b%a,a);
def reduce(a:!â„¤,b:!â„¤){ d:=gcd(a,b); return (a div d,b div d); }
def add(x:!â„¤^2,y:!â„¤^2)â‡’reduce(x[0]Â·y[1]+x[1]Â·y[0],x[1]Â·y[1]);
def inv(a:!â„¤,b:!â„¤)â‡’(b,a);
def from_cfrac(r:!â„¤[]):(!â„¤Ã—!â„¤)â‡’if r.length>1 then add((r[0],1),inv(from_cfrac(r[1..r.length]))) else (r[0],1);
+/

/+
def main(){
	return 2+(0:ğ”¹);
}
+/
/+
def foo[n:!â„•](x:ğ”¹^n):â„¤{
	return foo(x);
}
+/
/+
def main(){
	return f(0:ğ”¹,0:ğ”¹,0:ğ”¹);
}
+/

/+
def main(){
	return H(Z(rotZ(Ï€,H(0:ğ”¹))));
}
+/

/+
def main(){
	return 1e-10; // TODO
}
+/

/+
def main(){
	return 1.5:!â„š;
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	def f(x:ğ”¹):ğ”¹^1 â‡’ (x,);
	return f(x).length;
}
+/
/+
def main(){
	n:=5;
	//xs:=vector(n,0:ğ”¹);
	//with x:=xs[1] { x:=H(x); }
	x:=0:ğ”¹;
	with x:=H(x){
		x:=H(x);
	}
	return x;
}
+/
/+
k:=0;
def main(){
	forget(k);
	x:=k;
	def foo(){
		forget(x=0);
	}
	foo();
	foo();
}
+/
/+
def main(){
	x:=reverse(reverse);
}
+/
/+
def main(){
	return 3%-2;
}
+/
/+
def main(){
    program(f1);
    program(f2);
}

def program(f:ğ”¹!â†’mfree ğ”¹){
    x:=0:ğ”¹;
    y:=f(dup(x));
    if y{
        x:=H(x);
    }
	dump();
    y:=reverse(f)(y);
	assert(measure(y=x));
	forget(y=x);
    dump();
    measure(x);
}

def f1(x:ğ”¹)mfree{
    return rotY(Ï€/2,x);
}

def f2(x:ğ”¹)mfree{
    x:=Z(x);
    return rotY(Ï€/2,x);
}
+/
/+
def f(x:ğ”¹)mfreeâ‡’x;

def main(){
	x:=H(0:ğ”¹);
	y:=f(dup(x));
	if y{
		// ops
	}
	f(y):=y;
	assert(measure(y=x));
	forget(y=x);
	return x;
}
+/

/+
def f(x: ğ”¹) mfree: ğ”¹^2 {
	y := dup(x);
	// x := H(x);
	y := H(y);
	return (x, y);
}

def f'(x: ğ”¹) mfree: ğ”¹^2 {
	(x, y) := f(x);
	z := dup(y);
	f(x) := (x, y);
	return (x, z);
}

def main() {
	return f'(0:ğ”¹);
}
+/
/+

def main(){
	return 1%-2;
}
+/
/+
def main(){
	x:=0:ğ”¹;
	y:=0:ğ”¹;
	x:=H(x);
	if x{ phase(Ï€); }
	x:=H(x);
	return (x,y);
}
+/
/+
def f(x: uint[10]) mfree {
	x' := (x * 3) % 29;
	forget(x = (x' * 10) % 29);
	x'[0] := H(x'[0]);
	return x';
}

def main() {
	for i in [0..29) {
		x := i as uint[10];
		x := f(x);
		if x!=28 {
			phase(pi/2);
		}
		f(x) := x;
		measure(x);
	}
}
+/
/+
def H(x:ğ”¹){
	x:=rotY(-Ï€/4,x);
	if x{ phase(Ï€); }
	x:=rotY(Ï€/4,x);
	return x;
}
def main(){
	x:=1:ğ”¹;
	return H(1:ğ”¹);
}
+/

/+
import grover;
def main(){
	f:=(x:uint[8])liftedâ‡’xÂ·3=15;
	return grover(f);
}
+/
/+def main(){
	x:=0:ğ”¹;
	Ï†:=2Â·asin(1/2);
	x:=rotY(Ï†,x);
	x:=H(x);
	if x=1{ phase(Ï€); }
	x:=H(x);
	if x=1{ phase(Ï€); }
	x:=H(x);
	return x;
	//return x;
	//return Ï€/(4Â·asin(2^(-2/2)));
	/+x:=0:uint[2];
	for i in 0..2{ x[i]:=H(x[i]); }
	x[0]:=H(x[0]);
	x[1]:=H(x[1]);
	if x==3{ phase(Ï€); }
	for i in 0..2{ x[i]:=H(x[i]); }
	if x!=0{ phase(Ï€); }
	//for i in 0..2{ x[i]:=H(x[i]); }
	return x;+/
}
+/

/+
def f(x: B) mfree: B^2 {
	y := dup(x);
	y := H(y);
	return (x, y);
}
def main(){
	return reverse(f)(0:ğ”¹,1:ğ”¹);
}
+/

/+
def foo(x:ğ”¹)(y:ğ”¹)â‡’(y,x);
def bar(z:ğ”¹)â‡’z;

def main(){
	return foo(0:ğ”¹)(1:ğ”¹);
}
+/
/+
def main(){
	x:=0:!int[2];
	y:=0:!int[2];
	return x^y;
}
+/
/+
def main(){
	x:=0:ğ”¹;
	(y,z,w,t):=(1,0,0,0);
	for i in 0..10{
		(z,t,y,w)=(y/10,w,t,z);
		x:=H(x);
	}
	return x;
}
+/

/+
def main(){
	[a,(b,c)]:=[1,2]; // error
	return [a,b];
}
+/
/+
def main(){
	x:=vector(2,vector(2,0:ğ”¹));
	x[0]:=x[0]:ğ”¹[]; // error
}
+/
/+
x:=3;

def main(){
	//2+3:=(1,2);
	x:=3:uint[16];
	//():=forget(x=3);
	forget(x=3);
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	y:=H(0:ğ”¹);
	a:=measure(H(0:ğ”¹));
	b:=measure(H(0:ğ”¹));
	def foo(){
		//(x,y):=(x,y);
		if a{
			if b{
				t:=(x,y);
			}else{
				t:=(x,y);
			}
		}else{
			if b{
				t:=(x,y);
			}else{
				t:=(x,y);
			}
		}
		return t;
	}
	return foo;
}
+/
/+
def main(){
	x:=2;
	def foo()â‡’x;
	return foo;
}
+/

/+
def solve[n:!â„•](qs:ğ”¹^n){
	x:=measure(qs);
	return x;
}

def main(){
	return solve(0:ğ”¹,);
}
+/
/+
def min(x:!â„)lifted:!â„{
	r:=x;
	if true{
		r=2;
		__show(__query("type",r));
	}else{
		__show(__query("type",r));
		r=3;
	}
	return r;
}
+/

/+
def pad[a:!â„•](x:uint[a],b:!â„•)qfreeâ‡’((x as ğ”¹^a)~vector(b,0:ğ”¹)) as uint[a+b];
def powm[n:!â„•,m:!â„•](a:uint[n],b:uint[m])lifted: uint[2Â·n]{
	(r,x):=(1:uint[2Â·n], pad(a,n));
	for i in 0..m{
		__show(__query("dep",r));
		if b[i]{
			__show("1");
			__show(__query("dep",r));
			__show(__query("dep",x));
			r=rÂ·x;
			__show(__query("dep",r));
			__show(__query("dep",x));
			__show("2");
		}else{
			__show("3");
			__show(__query("dep",r));
			__show(__query("dep",x));
			__show("4");
		}
		x=xÂ·x;
	}
	return r;
}
+/
/+
def main(){
	x:=2;
	if true{
		x=3;
	}else{
		x=4;
	}
}
+/
/+
def main(){
	x:=();
	x:=move(x)~(0:ğ”¹,);
}
+/
/+
def bad(Ï†:!â„,_:ğŸ™)mfreeâ‡’_;
def main(){
	__show(__query("type",bad));
	reverse(bad)(Ï€/2,()):=();
}
+/

/+
def f(w: !Î [moved _:!â„•]lifted. qtype){}
//def f[moved _:!â„•]â‡’int[_];
def main(){
	f(int);
	__show(__query("type",f));
}
+/

/+
def main(){
	x:=();
	():=x;
	return x;
}
+/

/+
def main(){
	x:=((x:ğ”¹)qfreeâ‡’x)(true);
	__show(__query("type",x)); // !ğ”¹
	return x;
}
+/
/+
def fibâ‚[n:!â„•](i: int[n])lifted:int[n] â‡’ if iâ‰¤2 then i else fibâ‚(i-2)+fibâ‚(i-1);
def fibâ‚‚[n:!â„•](i: int[n])lifted:int[n]{
	(a,b):=(0,1):int[n]^2;
	j:=1:int[n];
	while true{
		if j<i{
			x:=dup(b);
			a+=x;
			(a,b):=(b,a);
			forget(x);
		}
		j=(j+(j<i));
	}
	r:=if iâ‰¤1 then i else dup(b);
	forget(a,b);
	return r;
}

def fibber(f: !Î [n:!â„•]lifted. int[n] !â†’lifted int[n]Ã—ğ”¹)[n:!â„•](i:int[n])lifted: int[n]Ã—ğ”¹{
	if iâ‰¤1{ return (i,true); }
	(a,a_ready):=f(i-2);
	(b,b_ready):=f(i-1);
	return (a+b,a_ready&b_ready);
}

def fibâ‚ƒ[n:!â„•](i:int[n]): int[n]{
	fib:=[n:!â„•](i:int[n])liftedâ‡’(0:int[n],false:ğ”¹);
	r:=0:int[n];
	done:=false;
	while !done{
		forget(r);
		fib=fibber(fib);
		(r,done):=fib(i);
		done:=measure(done);
		__show(__query("type",done));
	}
	return r;
}

def main(){
	return fibâ‚ƒ(10:int[10]);
}
+/
/+
def foo(){
	x:=H(0:ğ”¹);
	def bar(y:ğ”¹){
		x:=x;
		if y { x:=X(x); }
		return (x,y);
	}
	return bar;
}
def main(){
	return foo();
}
+/

/+
def main(){
	x:=(0:ğ”¹,);
	x[0]:=H(x[0]);
	__show(__query("type",qtype)); // ctype
	__show(__query("type",int[8]^3Ã—int[10]^3)); // qtype
	return x;
}
+/

/+
def f(const a:int[1],b:int[2])mfree:int[3] Ã— int[4]{
	forget(b=(0:int[2]));
	return (0:int[3], 0:int[4]);
}
+/

/+
def f(x:ğ”¹,)mfreeâ‡’x;

def main(){
	__show(__query("type",reverse(f)));
}
+/

/+
def main(){
	for i in [0..10){
		f:=((const x:ğ”¹)â‡’x+2): const ğ”¹!â†’!â„•;
	}
}
+/

/+
def main(){
	//def f()â‡’2;
	//forget(f);
	return H(0:ğ”¹);
}
+/

/+
def main(){
	x:=((0,2):!int[2]^2) as !â„¤^2;
	return x;
}
+/

/+
def main(){
	r:=reverse;
	return r((const x:ğ”¹,y:ğ”¹)mfreeâ‡’y); // TODO
}
+/

/+
def id(x:!â„•)â‡’x;

def main(){
	n:=3,m:=4;
	a:=5,b:=6;
	(n,(a,b))=(m,(b,a));
	return (n,(a,b));
}
+/

/+
def main(){
	i:=0;
	a:=(0,1):ğ”¹^2;
	b:=(0,1):ğ”¹^2;
	(a[i],a[i+1]):=(a[i],a[i+1]);
	return a;
}
+/

/+
k:=2;
def f2(x: int[32], y: int[32]){
	k := dup(x);
	forget(k);
	return (x,y);
}
+/

/+
def main(){
	n:=3;
	x:=vector(n,0:ğ”¹);
	c:=measure(H(0:ğ”¹));
	if c{
		forget(x);
		forget(n);
		n:=4;
		x:=vector(n,0:ğ”¹);
	}
	__show(__query("type",x));
	return (c,x);
}
+/

/+
def main(){
       q := vector(5, 0:ğ”¹);
       (qâ‚€, qâ‚, qâ‚‚, qâ‚ƒ, qâ‚„) := q;

       qâ‚€:=X(qâ‚€);
       qâ‚‚:=H(qâ‚‚);
       if qâ‚‚ { qâ‚€ := X(qâ‚€); }
       if qâ‚‚ { qâ‚„ := X(qâ‚„); }
       if qâ‚„ & qâ‚€{ qâ‚‚ := X(qâ‚‚); }
       if qâ‚ƒ { qâ‚ := X(qâ‚); }
       if qâ‚ƒ { qâ‚‚ := X(qâ‚‚); }
       if qâ‚‚ & qâ‚{ qâ‚ƒ := X(qâ‚ƒ); }
       if qâ‚‚ & qâ‚{ qâ‚ƒ := X(qâ‚ƒ); }
       if qâ‚ƒ { qâ‚‚ := X(qâ‚‚); }
       if qâ‚‚ { qâ‚ := X(qâ‚); }
       if qâ‚‚ { qâ‚€ := X(qâ‚€); }
       if qâ‚‚ { qâ‚„ := X(qâ‚„); }
       if qâ‚„ & qâ‚€ { qâ‚‚ := X(qâ‚‚); }

       /+qâ‚€ := X(qâ‚€);
       if qâ‚‚ { qâ‚€ := X(qâ‚€); }
       if qâ‚‚ { qâ‚„ := X(qâ‚„); }
       if qâ‚„ & qâ‚€ { qâ‚‚ := X(qâ‚‚); }
       if qâ‚ƒ { qâ‚ := X(qâ‚); }
       if qâ‚ƒ { qâ‚‚ := X(qâ‚‚); }
       if qâ‚‚ & qâ‚ { qâ‚ƒ := X(qâ‚ƒ); }
       if qâ‚‚ & qâ‚ { qâ‚ƒ := X(qâ‚ƒ); }
       if qâ‚ƒ { qâ‚‚ := X(qâ‚‚); }
       if qâ‚‚ { qâ‚ := X(qâ‚); }
       if qâ‚‚ { qâ‚€ := X(qâ‚€); }
       if qâ‚‚ { qâ‚„ := X(qâ‚„); }
       if qâ‚„ & qâ‚€ { qâ‚‚ := X(qâ‚‚); }+/

       q := (qâ‚€, qâ‚, qâ‚‚, qâ‚ƒ, qâ‚„);
       return q;
}
+/
/+
def foo(a:!â„•)(b:!â„•)â‡’a+b+c;
+/
/+
def main(){
	x:=H(0:ğ”¹);
	if x{
		f:=()=>x; // error
	}
}
+/

/+
def main(){
	a:=vector(3,0:ğ”¹);
	__show(__query("dep",a));
	a[0]:=H(a[0]);
	__show(__query("dep",a));
	return a;
}
+/

/+
def foo(a:!â„•)(b:!â„•)â‡’a+b;

def main(){
	return foo(1)(2);
}
+/
/+
def main(){
	f:=(x:!â„)â‡’(-1/2â‰¤xâˆ§xâ‰¤1/2):!â„;
	for i in [0..1){
		d:=1/(2Â·i+1);
		f=(x:!â„)â‡’f(x+d/2);
	}
	return f;
}
+/
/+
def rQFT[n:!â„•](Ïˆ: int[n])mfree{
    for k in (n..-1..0]{
        for l in (n..-1..k + 1]{
            if Ïˆ[k] && Ïˆ[l] {
                reverse(phase)(2 Â· Ï€ Â· 2 ^ (k - l - 1),());
            }
        }
        __tmp2 := Ïˆ[k];
        __tmp2 := reverse(H)(__tmp2);
        Ïˆ[k] := __tmp2;
    }
    for k in (n div 2..-1..0]{
        __tmp1 := Ïˆ[n - k - 1];
        __tmp0 := Ïˆ[k];
        (__tmp1,__tmp0) := (__tmp0,__tmp1)^2;
        Ïˆ[n - k - 1] := __tmp1;
        Ïˆ[k] := __tmp0;
    }
    return Ïˆ coerce int[n];
}

def main(){
	return rQFT(0:int[2]);
}
+/

//a:=vector(3,0:ğ”¹); // TODO
//(x,y):=(1,2); // TODO
//a[0]:=a[0]; // error

/+
def main(){
	[x,y]:=(1,2/3);
	__show(__query("type",y));
}
+/

/+
def main(){
	x:=0:ğ”¹;
	y:=f(dup(x));
	if y {
		z:=1:ğ”¹;
	}else{
		z:=0:ğ”¹;
	}
	y:=reverse(f)(y);
	assert(measure(y=x));
	forget(y=x);
	return z;
}
+/

/+
def project0(x:ğ”¹){
	assert(measure(x=0));
	0:=x;
}
def project1(x:ğ”¹){
	assert(measure(x=1));
	1:=x;
}

def main(){
	x:=0:ğ”¹;
	y:=H(0:ğ”¹);
	assert(measure(x=y));
	dup(x):=y;
}

def main(){
	0:=H(0:ğ”¹);
	x:=1:ğ”¹;
	y:=H(dup(x));
	if y{
		z:=H(x);
	}else{
		z:=H(x);
	}
	y:=H(y);
	assert(measure(z==y));
	forget(y=z);
	return z;
}
+/

/+

def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	measure(dup(x));
	forget(y);
	return x;
}
+/
/+
def f(a: ğ”¹){
	x:=!a; // x â†¦ {a}
	y:=!x; // x â†¦ {a}, y â†¦ {x}
	if y {
		xp := dup(x); // xp â†¦ {x}, x â†¦ {a}, y â†¦ {x}
		__show(__query("dep",xp));
		xp := H(xp);
		// y â†¦ {x}, x â†¦ {a}
	} else {
		xp := dup(x); // x=xp, y â†¦ {x}, x â†¦ {a}
		// xâ†¦{xp}, y â†¦ {x}, xp â†¦ {a}
		a := H(a);
		// x â†¦ {xp}, y â†¦ {x}, xp â†¦ {a}
	}
	// x â†¦ {xp}, y â†’ {xp}
	(x,xp) := (xp,x); // x â†’ âŠ¤,
	// x â†¦ {y, a, ap}, y â†¦ {cond, x, xp}
	__show(__query("dep",y));
	forget(xp);
	return (x,a,y);
}
+/

/+
def f(a: B) {
	y := !a;
	y := X(y);
	a := H(a);
	__show(__query("dep",y));
	forget(y);
	return a;
}
+/

/+
def foo(x:ğ”¹,y:ğ”¹,n:!â„•){
	(a,b):=(dup(x),dup(y));
	repeat n{
		(a,b):=(b,a);
	}
	__show(__query("dep",a)); // {y, x}
	__show(__query("dep",b)); // {y, x}
}
+/
/+
def main(){
	x:=1;
	y:=H(0:ğ”¹);
	if y{
	}else{
	}
	measure(y);
	return x;
}
+/
/+
def factored(const cond:ğ”¹,x:ğ”¹)mfree{
	if cond{
		x:=H(x);
	}else{
		//a:=H(a);
	}
	return (x);
}

def foo(a:ğ”¹,const cond:ğ”¹,const cond2:ğ”¹){
	if cond2 {
		x:=!a;
		y:=!x;
		if cond{
			x:=H(x);
			// forget(y=a);
		}else{
			a:=H(a);
			// forget(y=!x)
			//z:=x;
		}
		//(x):=factored(cond,x);
		__show(__query("dep",y));
		forget(y); // error
		return (a,x);
	}else{
		return (a,0:ğ”¹);
	}
}
+/

/+
def main(){
	x:=0:!â„‚;
	y:=1:!â„¤;
	return x^y;
}
+/

/+
def main(){
	foo(bar(x,y),z);
}
+/

/+
x:=foo()+y;
y:=2;

def foo():â„¤{ assert(false); }
+/

//(x,y):=(1,2);
//y:=x;

/+
def main(){
	return 764/382;
}
+/
/+
def main(){
	(x:!â„•,y:!â„¤) := (-2,3);
}
+/
/+
def main(){
	x:=0:uint[(1,2.0).length];
	y:=x:uint[2];
}
+/
/+
def main(){
	//x:=(H(0:ğ”¹),H(1:ğ”¹),H(2:ğ”¹));
	//z:=H(0:ğ”¹);
	//y:=
	print(1,23);
	exit();
}
+/
/+
def main(){
	x:=(0:!ğ”¹,H(0:ğ”¹));
	x[1]:=H(x[1]);
	return x;
}
+/
/+
def main(){
	x:=(0,1/2);
	i:=0;
	return x[i];
}
+/
/+
def main(){
	x:=-2;
	return x^0:!â„•;
}
+/
/+
def expensive_pure_computation()qfreeâ‡’3;

def main(){
	x:=0:int[expensive_pure_computation()];
}
+/

/+
def main(){
	x:=(1,[2,3],4);
	y:=(3,4);
	return x~y;
}
+/
/+
def main(){
	x:=1:ğ”¹;
	//forget(x=3);
	reverse(dup[ğ”¹])(H(measure(x)),x);
	//return x;
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	y:=H(0:ğ”¹);
	forget((dup(x),dup(y))=(x,y));
	return (x,y);
}
+/
/+
def f(const x:ğ”¹)qfreeâ‡’x;

def main(){
	x:=f(0:ğ”¹);
	y:=f(x);
	def foo(){
		y:=y;
		__show(__query("dep",y));
	}
}
+/

/+
def fâ‚(const z: ğ”¹) qfree: ğ”¹ {
	return !z;
}
def fâ‚‚() qfree: ğ”¹^2 {
	return (0:ğ”¹, 0:ğ”¹);
}

def main() {
	x := H(0:ğ”¹);
	y := H(0:ğ”¹);
	a := 0:ğ”¹;
	b := 0:ğ”¹;
	c := 0:ğ”¹;
	if x {
		(a,b) = fâ‚‚();
		c = fâ‚(y);
	} else {
		a = fâ‚(y);
		(b,c) = fâ‚‚();
	}
	__show(__query("dep",a));
	__show(__query("dep",b));
	__show(__query("dep",c));
	forget(a,c);
	if b {
		y := X(y);
	} else {
		y := Z(y);
	}
	forget(b);
	return (x, y);
}
+/

/+
def main(){
	x:=1:*; // TODO?
}
+/
/+
def main(){
	//x:=2:!int[3];
	//return x: !â„•;
	x:=2:Î (x:â„•). â„•;
}
+/
/+
def main(){
	x:=2:!â„‚;
	y:=abs(x);
	__show(__query("type",y));
	return x+2;
}
+/
/+
def main(){
	//x:=.0;
	//__show(__query("type",x));
	//x:=1+if true { 5 } else { 3 };
	//if false then def foo(){} else def foo() â‡’ 3;
	//x:=1+(x:=2);
	return foo();
}
+/
//y:=(1,2,3);
//a:=2;

/+
def main(){
	a:=vector(10,0:ğ”¹);
	(a[0],b):=(H(a[0]),1:ğ”¹);
	__show(__query("dep",a)); // âŠ¤
	__show(__query("dep",b)); // {}
	measure(a);
}
+/
/+
def main(){
	a:=vector(10,0:ğ”¹);
	a[0]:=H(a[0]);
	__show(__query("dep",a)); // âŠ¤
	measure(a);
}
+/
/+
def foo(x:ğ”¹,y:ğ”¹){
	//z:=dup(x);
	a:=dup(x);
	b:=dup(y);
	__show(__query("dep",a));
	__show(__query("dep",b));
	(a,b):=(b,a);
	__show(__query("dep",a));
	__show(__query("dep",b));
	//__show(__query("dep",z));
	return (x,y);
}
+/
/+
def foo(x:ğŸ™)â‡’();

def main(){
	x:=();
	foo(x);
	return x:ğŸ™;
}
+/
/+
def wat[f: ğ”¹!->qfree !â„•,g: 1->qfree ğ”¹](): (!ğ”¹^f(g()))[]{ // error
    return ();
}
def mi(x: ğ”¹): !â„• {
	r := measure(x) as !â„•;
	print(r);
	return r;
}

def main(){
	x := H(0:ğ”¹);
	y := dup(x);
	wat[mi, lambda(). x]();
	return y;
}
+/
/+
def main(){
	x:=vector(5,0:ğ”¹);
	y:=H(x[0]);
	return (x,y);
}
+/
/*
def main(){
	q := 0:uint[n];
	anc := op(q, 0:B);
}
*/
/*
def main(){
	def bar(){
		x:=0:ğ”¹;
		def foo(x:ğ”¹){
			x:=x;
			return x;
		}
		return foo(x);
	}
	return bar();
}
*/
/+
def main(){
	return int[2^-1];
}
+/
/+
def foo(a:!â„•)(b:!â„•)â‡’a+b+c;
+/

/+
def main(){
	x:=0:uint[10];
	y:=-1:int[10];
	return x<y;
}
+/
/+
def main(){
	return -4&-2;
}
+/

/+
def main(){
	x:=2:int[32];
	return x^2; // TODO: should work with exponent of type !â„•
}
+/
/+
def main(){
	x:=0:classical B;
	x=0:ğ”¹;
}
+/

/+
def arrId(a: B[]) mfree: B[] {
	return a;
}

def doThenRev[T](f: T!->mfree T, val: T): T {
	return reverse(f)(f(val));
}

def main() {
	if measure(H(0:B)) {
		v := doThenRev[B[]](arrId, []: B[]);
	} else {
		v := []: B[];
	}
	return v;
}
+/
/+
def main(){
	x:=[]:(ğ”¹^2)[];
	y:=x coerce (ğ”¹^3)[];
}
+/
/+
def main() {
	a := [0:B];
	(x: B^1)~a := a;
	return (x,a);
}
+/
/+
def main(){
	x:=0:ğ”¹;
	v:=vector(measure(x),0:ğ”¹):*;
}
+/

/+
def wat[f: B!->!N,g: 1->B](): (!B^f(g()))[]{
    return ();
}

def mi(x: B): !N {
	r := measure(x) as !N;
	print(r);
	return r;
}

def main(){
	x := H(0:ğ”¹);
	y := dup(x);
	wat[mi, lambda(). x]();
	return y;
}
+/
/+
def wat[f: B!->!N, g: 1!->B](): (B^f(g()))[] {
	//return [vector(f(g()), 0:B)];
	return ();
}

def mi(x: B): !N {
	return measure(x) as !N;
}

def mkh(): B {
	return H(0:B);
}

def main() {
	return wat[mi,mkh]();
}
+/

/+
def sum[a,b] â‡’ Î [c](f: a!â†’c, g: b!â†’c). c;
def inl[a,b](x:a)[c](f: a!â†’c, g: b!â†’c)â‡’f(x);
def inr[a,b](x:b)[c](f: a!â†’c, g: b!â†’c)â‡’g(x);
def match[a,b,c](val: Î [c](f: a!â†’c, g: b!â†’c). c, f: a!â†’c, g: b!â†’c)â‡’val(f,g);

def main(){
	x:=inl[ğ”¹,ğ”¹^2](H(0:ğ”¹)); // error
	y:=inr[ğ”¹,ğ”¹^2](H(0:ğ”¹),H(1:ğ”¹)); // error
}
+/

/+
def sum[a,b] â‡’ Î [c](f: a!â†’c, g: b!â†’c). c;
def inl[a,b](x:a)[c](f: a!â†’c, g: b!â†’c)â‡’f(x);
def inr[a,b](x:b)[c](f: a!â†’c, g: b!â†’c)â‡’g(x);
def match[a,b,c](val: Î [c](f: a!â†’c, g: b!â†’c). c, f: a!â†’c, g: b!â†’c)â‡’val(f,g);

def main(){
	k:=H(0:ğ”¹);
	if k{
		x:=inl[ğ”¹,ğ”¹^2](H(0:ğ”¹)); // TODO
	}else{
		x:=inr[ğ”¹,ğ”¹^2](H(0:ğ”¹),H(1:ğ”¹));
	}
	//x:=inl[ğ”¹,ğ”¹^2](H(0:ğ”¹));
	//dump();
	//y:=inr[ğ”¹,ğ”¹^2](H(0:ğ”¹),H(1:ğ”¹));
	//measure(y);
	return match[ğ”¹,ğ”¹^2,!â„•]( // TODO: should be able to infer
		x,
		(a:ğ”¹)â‡’measure(a):!â„•,
		(b:ğ”¹^2){ (u,v):=measure(b); return u+v; },
	);
	//dump();
}
+/

/+
def main()â‡’(3,3)=(2,1);
+/
/+
def list[Ï„:*]â‡’Î [a:*](nil: !a)(cons: !Ï„Ã—!a!â†’lifted !a). a;
def nil[Ï„:*][a:*](nil:!a)(cons:!Ï„Ã—!a!â†’lifted!a)liftedâ‡’nil;
def cons[Ï„:*](head:!Ï„,tail:!Î [a:*]lifted. !Î (nil: !a)lifted. !Î (cons: !Ï„Ã—!a!â†’lifted!a)lifted. !a)[a:*](nil:!a)(cons:!Ï„Ã—!a!â†’lifted!a)liftedâ‡’cons(head,tail[a](nil)(cons));
def foldr[Ï„:*,a:*](nil:!a,cons:!Ï„Ã—!a!â†’lifted!a)(xs: !Î [a:*]lifted. !Î (nil: !a)lifted. !Î (cons: !Ï„Ã—!a!â†’lifted!a)lifted. !a)liftedâ‡’xs[a](nil)(cons);
def len[Ï„:*]â‡’foldr[Ï„,â„•](0,(x:!Ï„,l:!â„•)qfreeâ‡’1+l);

def sum(xs: !Î [a:*]lifted. !Î (nil: !a)lifted. !Î (cons: !â„•Ã—!a!â†’lifted!a)lifted.!a)â‡’foldr[â„•,â„•](0,(x:!â„•,y:!â„•)qfreeâ‡’x+y)(xs);

def main()â‡’sum(cons[!â„•](2,cons[!â„•](1,nil[!â„•])));
+/
/+

def partition[n:!â„•](xs: !â„•^n,l:!â„•,r:!â„•,p:!â„•){
	ys:=xs;
	q:=p;
	(ys[p],ys[r])=(ys[r],ys[p]);
	(i,j):=(l,r-1);
	done:=false;
	while !done{
		while iâ‰¤j && ys[i]<ys[r]{ i+=1; }
		while iâ‰¤j && ys[j]â‰¥ys[r]{ j-=1; }
		if i>j { (ys[i],ys[r])=(ys[r],ys[i]); q=i; done=true; }
		else { (ys[i],ys[j])=(ys[j],ys[i]); i+=1, j-=1; }
	}
	return (ys,q);
}
def quickSelect[n:!â„•](xs: !â„•^n,l:!â„•,r:!â„•,k:!â„•){
	p:=(l+r) div 2; // TODO: random
	(ys,t):=partition(xs,l,r,p);
	print(xs,ys,l,r,t);
	if t==k { return ys; }
	if t>k { return quickSelect(ys,l,t sub 1,k); }
	else { return quickSelect(ys,t+1,r,k); }
}

def main(){
	return quickSelect((1,2,3,4,0,5,6),0,6,6);
	//return quickSelect((0,1,0,1,0,0,0),0,6,2);
}
+/
/+
def foo(f: ğŸ™â†’ğ”¹){
	if f(){}
}
+/
/+
def main(){
	x:=1:!int[5];
	y:=2:!int[5];
	return x div y;
}
+/
/+
def high_level[Î¸:!â„](Ïˆâ‚€:ğ”¹,Ïˆâ‚:ğ”¹,cat:ğ”¹)mfree{
	if Ïˆâ‚€âˆ§Ïˆâ‚ âˆ¨ Ïˆâ‚€âˆ§!cat âˆ¨ Ïˆâ‚âˆ§!cat { phase(2Â·Î¸); }
	catâŠ•=Ïˆâ‚€âŠ•Ïˆâ‚;
	return (Ïˆâ‚€,Ïˆâ‚,cat);
}
+/
/+def high_level[Î¸:!â„](Ïˆâ‚€:ğ”¹,Ïˆâ‚:ğ”¹,cat:ğ”¹)mfree{
	def tmp(Ïˆâ‚€:ğ”¹,Ïˆâ‚:ğ”¹,cat:ğ”¹)liftedâ‡’Ïˆâ‚€âˆ§Ïˆâ‚ âˆ¨ Ïˆâ‚€âˆ§!cat âˆ¨ Ïˆâ‚âˆ§!cat;
	forget(rotZ(2Â·Î¸,tmp(Ïˆâ‚€,Ïˆâ‚,cat))=tmp(Ïˆâ‚€,Ïˆâ‚,cat));
	catâŠ•=Ïˆâ‚€âŠ•Ïˆâ‚;
	return (Ïˆâ‚€,Ïˆâ‚,cat);
}+/
/+
def low_level[Î¸:!â„](Ïˆâ‚€:ğ”¹,Ïˆâ‚:ğ”¹,cat:ğ”¹)mfree{
	cat:=X(cat);
	Ïˆâ‚âŠ•=Ïˆâ‚€;
	catâŠ•=Ïˆâ‚€;
	forget(rotZ(2Â·Î¸,Ïˆâ‚€âŠ•(Ïˆâ‚âˆ§cat))=Ïˆâ‚€âŠ•(Ïˆâ‚âˆ§cat));
	catâŠ•=Ïˆâ‚;
	catâŠ•=Ïˆâ‚€;
	Ïˆâ‚âŠ•=Ïˆâ‚€;
	cat:=X(cat);
	return (Ïˆâ‚€,Ïˆâ‚,cat);
}
+/
/+
def dummy[Î¸:!â„](Ïˆâ‚€:ğ”¹,Ïˆâ‚:ğ”¹,cat:ğ”¹)mfree{
	return (rotZ(Î¸,Ïˆâ‚€), rotZ(Î¸,Ïˆâ‚), cat);
	//if Ïˆâ‚€ { phase(Î¸); }
	//if Ïˆâ‚ { phase(Î¸); }
	//return (Ïˆâ‚€,Ïˆâ‚,cat);
}
+/
/+
def main(){
	Î¸:=Ï€/3;
	cat:=rotZ(Î¸,H(0:ğ”¹));
	(Ïˆâ‚€,Ïˆâ‚):=(H(0:ğ”¹),H(1:ğ”¹));
	//measure(Ïˆâ‚€,Ïˆâ‚);
	(Ïˆâ‚€,Ïˆâ‚,cat):=dummy[Î¸](Ïˆâ‚€,Ïˆâ‚,cat);
	(Ïˆâ‚€,Ïˆâ‚,cat):=reverse(high_level[Î¸])(Ïˆâ‚€,Ïˆâ‚,cat);
	return (H(Ïˆâ‚€),H(Ïˆâ‚),H(rotZ(-Î¸,cat)));
	//measure(cat,Ïˆâ‚);
	//return (Ïˆâ‚€);
	/*x:=0:ğ”¹;
	if x { phase(Ï€); } else { phase(-Ï€); }
	return x;//rotZ(-Ï€,x);*/
}
+/
/+
def fib[n:!â„•](const x: uint[n])qfree: uint[n]{
	if x <= 1 { return x; }
	else { return fib(x-1)+fib(x-2); }
}

def main(){
	k:=H(0:ğ”¹);
	return (fib((0:uint[4])+k),k);
}
+/

/+
import qftPretty;
def main(){
	n:=5;
	x:=0:uint[5];
	y:=13:uint[5];
	y[0]:=H(y[0]);
	//x:=QFT(x);
	for i in [0..n){ x[i]:=H(x[i]); }
	phaseQ(x*y);
	x:=reverse(QFT)(x);
	//forget(y=x);
	return (x,y);
}
+/
//def add[n:!â„•](a:uint[n],b:uint[n])liftedâ‡’a+b;
/+
def add[n:!â„•](a:uint[n],b:uint[n])lifted{
	c:=0:uint[n];
	carry:=0:ğ”¹;
	for i in [0..n){
		c[i]=a[i]âŠ•b[i]âŠ•carry;
		carry=a[i]&b[i]|a[i]&carry|b[i]&carry;
	}
	return c;
}

def main(){
	a:=13:uint[32];
	b:=24:uint[32];
	a[0]:=H(a[0]);
	b[1]:=H(b[1]);
	return (add(a,b),a,b);
}
+/
/+
import qftPretty;

def draper_mult_impl[n:!â„•](const a: uint[n],const b: uint[n])mfree: uint[n]{
	Ï†:=QFT(0:uint[n]);
	for i in [0..n){
		for j in [0..n){
			if Ï†[i] && b[j]{ phaseQ(2^(i+j)Â·a); }
		}
	}
	return reverse(QFT)(Ï†);
}

def draper_mult[n:!â„•](const a: uint[n],const b: uint[n])qfree: uint[n]{
	return (draper_mult_impl[n] pun const uint[n]Ã—const uint[n]!â†’qfree uint[n])(a,b);
}

def main(){
	n:=3;
	i:=3, j:=2;
	a:=i as uint[3], b:=j as uint[3];
	c:=draper_mult_impl(dup(a),b);
	//forget(c=draper_add(dup(a),b));
	//k:=measure(draper_add(a,b));
	//assert((k as !uint[n])==(i*j as !uint[n]));
	return c;
}
+/

/+
import qft;

def draper_add_impl[n:!â„•](a: int[n],const b: int[n])mfree: int[n]{
	a := QFT(a);
	for k in [0..n){
		for l in [0..n-k){
			if a[k] && b[l]{
				phase(2Â·Ï€Â·2^(k+l-n));
			}
		}
	}
	return reverse(QFT)(a);
}

def draper_add[n:!â„•](a: int[n],const b: int[n])qfree: int[n]{
	return (draper_add_impl[n] pun int[n]Ã—const int[n]!â†’qfree int[n])(a,b);
}

def main(){
	for i in [-2^3..2^3){
		for j in [-2^3..2^3){
			a:=i as int[4], b:=j as int[4];
			c:=draper_add(dup(a),b);
			forget(c=draper_add(dup(a),b));
			k:=measure(draper_add(a,b));
			print(i,j,i+j,k,(i+j)%(2^4),k%(2^4),(-8)%16);
			assert(k%2^4==(i+j)%2^4); // TODO: investigate this
		}
	}
	dump();
}
+/
/+
def foo(a:!â„•)(b:!â„•)â‡’a+b;

def main(){
	return foo(1)(2);
}
+/

/+
def higherRankedFunction(f: !Pi[a:*]. a!->a) => f([f(1),f(2)]);
def main() â‡’ higherRankedFunction([a:*](x:a)=>x);
+/
/+
def main(){
	x:=false;
	y:=false;
	if x {
		y=true;
	}else{
		y=false;
	}
	//y:=true;
	//return y;
}
+/
/+
def foo[n:!â„•](xs:!â„•^n,ys:!â„•^n)lifted{
	print(n);
	return (xs,ys);
}

def main(){
	print(foo((1,2,3,4),(1,2,3,4)));
}
+/

/+
def zip[Ïƒ:*,Ï„:*,n:!â„•](xs: Ïƒ^n, ys: Ï„^n)mfree: (ÏƒÃ—Ï„)^n {
	if n=0 {
		():=xs coerce Ïƒ^0;
		():=ys coerce Ï„^0;
		r:=() coerce (ÏƒÃ—Ï„)^n;
	} else {
		xs~(x,) := xs;
		ys~(y,) := ys;
		r := zip(xs,ys)~((x,y),);
	}
	return r;
	/*xs:=xs:Ïƒ[];
	ys:=ys:Ï„[];
	r:=[]:(ÏƒÃ—Ï„)[];
	for i in 0..n{
		(xs~(x,),ys~(y,)) := (xs,ys);
		r~=[(x,y)];
	}
	__show(__query("type",xs));
	():=xs;
	():=ys;
	return r coerce (ÏƒÃ—Ï„)^n;*/
}

def unzip[Ï„:*,n:!â„•](x: (Ï„^2)^n){
	zip(x,y):=x;
	return (x,y);
}

def map[Ïƒ:*,Ï„:*](f: Ïƒ !â†’mfree Ï„)[n:!â„•](xs: Ïƒ^n)mfree: Ï„^n{
	ys := []:Ï„[];
	xs := xs:Ïƒ[];
	for i in 0..n{
		(x,)~xs := xs;
		ys~=[f(x)];
	}
	//__show(__query("dep",xs));
	():=xs;
	return ys coerce Ï„^n;
	/+if n=0{
		():=xs coerce Ïƒ^0;
		r:=() coerce Ï„^n;
	}else{
		(x,)~xs := xs;
		r:=(f(x),)~map(f)(xs);
	}
	return r;+/
}

def add(x:!â„¤)(y:!â„¤) â‡’ x+y;

def main(){
	//return zip((1,2,3),(3,4,5));
	//zip(x,y) :=
	//return unzip((1,3),(2,4),(3,5));
	def mapzip[Ïƒ:*,Ï„:*,n:!â„•,m:!â„•]qfree â‡’ map(zip[Ïƒ,Ï„,n])[m];
	/*return mapzip(
		((1,2,3), (3,4,5)),
		((0,2,3), (5,4,5)),
	);*/
	//mapzip(x):=(((1,3),(2,4),(3,5)),((0,5),(2,4),(3,5)));
	//return x;
	return unzip((1,2),(3,4),(4,5));
}
+/

/+
def add[n:!â„•](x: !â„¤^n, y: !â„¤^n){
	r := vector(n, 0:!â„¤);
	for i in 0..n{
		r[i]=x[i]+y[i];
	}
	return r;
}

def main(){
	n := 2+3*measure(H(0:ğ”¹))+measure(H(0:ğ”¹));
	x := vector(n, 0);
	y := vector(n, 0);
	return add(x,y):!â„¤[];
}
+/
/+
def f[T:*](x:T){
	return x;
}

def main(){
	//x := 4;
	//return f(x);
	return (1,2):!â„¤^2;
}
+/

/+
def main(){
	return 30 % -40;
}
+/
/+
def makeTeleporter(){
	sharedâ‚€:=H(0:ğ”¹);
	sharedâ‚:=dup(sharedâ‚€);
	def send(message:ğ”¹){
		sharedâ‚€:=sharedâ‚€;
		sharedâ‚€âŠ•=message;
		return measure(H(message),sharedâ‚€);
	}
	def receive(p:!ğ”¹,f:!ğ”¹){
		sharedâ‚:=sharedâ‚;
		if p && sharedâ‚ { phase(Ï€); }
		if f { sharedâ‚:=X(sharedâ‚); }
		return sharedâ‚;
	}
	return (send,receive);
}

def main(){
	(send,receive):=makeTeleporter();
	//return (send,receive);
	x:=send(H(1:ğ”¹));
	return receive(x);
}
+/
/+
def deutsch(f: ğ”¹Ã—ğ”¹ â†’ ğ”¹Ã—ğ”¹){
	x:=H(0:ğ”¹);
	anc:=H(1:ğ”¹);
	(x,anc):=f(x,anc);
	measure(anc);
	return x;
}

def main(){

}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	y:=H(0:ğ”¹);
	return x;
}
+/
/+
def deutsch(f: ğ”¹ !â†’lifted ğ”¹){
	x:=H(0:ğ”¹);
	y:=H(1:ğ”¹);
	if f(x){ phase(Ï€); }
	return measure(H(x));
}
+/
/+
def func[n:!â„•](const p:B, q:uint[n]){
    if p {
        q = 3:uint[n];  // Error: cannot reassign quantum variable
    }
    return q;
}
+/
/*
def main(){
	q := 0:uint[n];
	anc := op(q, 0:B);
}
*/
/*
def main(){
	def bar(){
		x:=0:ğ”¹;
		def foo(x:ğ”¹){
			x:=x;
			return x;
		}
		return foo(x);
	}
	return bar();
}
*/
/+
def main(){
	return int[2^-1];
}
+/
/+
def foo(a:!â„•)(b:!â„•)â‡’a+b+c;
+/
/+
def main(){
	//x:=(1,1):ğ”¹ x ğ”¹;
	x:=uint;
	return x[3];
}
+/
//def main()â‡’measure(H(0:ğ”¹));

/+
def main(){
	n:=3,m:=3;
	x:=vector(n,vector(m,0:ğ”¹));
	(x[1],x[1][2],x[2][1],x[2]):=(x[2],x[2][1],x[1][2],x[1]);
}
+/

/+
def map[a,b,n:!â„•](f: a!â†’mfree b, xs: a^n)mfree: b^n{
	if n==0{ forget(xs=()); result := () coerce b^n; }
	else { (x,)~xs:=xs; result := (f(x),)~map(f, xs); }
	return result;
}

def zip[a,b,n:!â„•](xs:a^n,ys:b^n)qfree:(aÃ—b)^n{
	xs:=xs:a[];
	ys:=ys:b[];
	r:=[]:(aÃ—b)[];
	repeat n{
		(x,)~xs:=xs;
		(y,)~ys:=ys;
		r~=[(x,y)];
	}
	return r coerce (aÃ—b)^n;
}

def unzip[a,b,n:!â„•](xs:(aÃ—b)^n)qfree:a^nÃ—b^n{
	xs:=xs:(aÃ—b)[];
	rs:=[]:a[];
	qs:=[]:b[];
	repeat n{
		((r,q),)~xs:=xs;
		rs~=[r];
		qs~=[q];
	}
	return (rs,qs) coerce a^nÃ—b^n;
}

def W(a:ğ”¹,b:ğ”¹)mfree{
	a:=H(a);
	aâŠ•=b;
	b:=H(b);
	bâŠ•=a;
	return (a,b);
}

n:=2;
def main(){
	x:=0:uint[n];
	// do some stuff to x
	y:=0:uint[n];
	// do some stuff to y
	(x,y):=unzip(map(W, zip(x as ğ”¹^n,y as ğ”¹^n))) as int[n]^2;
	return (x,y);
}
+/

/+
def map[a,b,n:!â„•](f: a!â†’mfree b, xs: a^n)mfree: b^n{
	if n==0{ forget(xs=()); result := () coerce b^n; }
	else { (x,)~xs:=xs; result := (f(x),)~map(f, xs); }
	return result;
}
def concatenate[a,m:!â„•,nâ‚:!â„•,nâ‚‚:!â„•](xss: (a^nâ‚)^m, yss: (a^nâ‚‚)^m)qfree: (a^(nâ‚+nâ‚‚))^m{
	if m == 0{
		forget(xss=());
		forget(yss=());
		return () coerce (a^(nâ‚+nâ‚‚))^m;
	}
	(xs,)~xss:=xss;
	(ys,)~yss:=yss;
	return (xs~ys,)~concatenate(xss,yss);
}

def transpose[a,m:!â„•,n:!â„•](xss:(a^n)^m)qfree:(a^m)^n{
	if m == 0 {
		forget(xss=());
		result:=vector(n,():a^0) coerce (a^m)^n;
	}else if m == 1{
		(xs,)~xss:=xss;
		forget(xss=());
		r:=[]:(a^1)[];
		xs:=xs:a[];
		for i in 0..n{
			(x,)~xs:=xs;
			r~=[(x,)];
		}
		forget(xs=());
		result:=r coerce (a^m)^n;
	}else{
		(xs,)~xss:=xss;
		result:=concatenate(transpose(xs,),transpose(xss));
	}
	return result;
}
+/

/+
n := 2;
def main(){
	x:=0:uint[n];
	// do some stuff to x
	y:=0:uint[n];
	// do some stuff to y
	for i in 0..n{
		// move (x[i], y[i]) out of array:
		(a,b) := (x[i],y[i]):ğ”¹^2;
		x[i] := CNOT(a,x[i]);
		y[i] := CNOT(b,y[i]);
		// apply gate
		(a,b) := W(a,b);
		// move (a,b) back into array:
		x[i] := CNOT(a,x[i]);
		y[i] := CNOT(b,y[i]);
		forget((a,b)=(x[i],y[i]));
	}
	return (x,y);
}
+/

/+
def foo[n:!â„•](xs:â„^n){
	return xs;
}

def bar[n:!â„•,m:!â„•](xs:â„^n,ys:â„^m):â„^(n+m){
	return xs~ys;
}

def main(){
	//return foo[4](1,2,3,4);
	return bar((1,2),(3,4,5));
}
+/

/+
def main(){
	return rotY(Ï€/4,0:ğ”¹);
}
+/
/+
n:=10;
def main(){
	x:=vector(n sub 1,0:ğ”¹);
	/+for i in 0..n-1{ x[i]:=H(x[i]); }
	y:=1:ğ”¹;
	for i in 0..n-1{ yâŠ•=x[i]; } }
	x:=x~(y,);
	for i in 0..n{ x[i]:=H(x[i]); }+/
	y:=H(0:ğ”¹);
	for i in 0..n{ x[i]:=CNOT(y,x[i]); }
	x:=x~(y,);
	return x;
}
+/

/+
def x1_xor_xn[n:!â„•](x:ğ”¹^n)liftedâ‡’x[0]âŠ•all(x[1..n]);

def main(){
	x:=-1 sub -2 coerce !â„•;
	return x1_xor_xn();
}

def all[n:!â„•](x:ğ”¹^n)lifted{
	r:=1:ğ”¹;
	for i in 0..n{ r&=x[i]; }
	return r;
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	return CNOT(dup(x),x);
}
+/

/+def deutsch(f: ğ”¹ !â†’lifted ğ”¹){
	x:=H(0:ğ”¹);
	if f(x){ phase(Ï€); }
	return measure(H(x));
}+/
/+def main(){
	x:=vector(6,0:ğ”¹);
	return x;
}
+/

/+
def main[n:!â„•](){
	return (ğ”¹, int[n]):*^2;
}
+/
/+
def main(){
	xâ‰”1;
}
+/
/+
def main(){
	x:=1:ğ”¹;
	y:=dup(x);
	//return (x,Z(y));
	dump();
	return (x,y);
}
+/
/+
def main(){
	//return H(0:ğ”¹,1:ğ”¹,0:ğ”¹);
	x:=(0:ğ”¹,1:ğ”¹,0:ğ”¹);
	//x[0,1]:=H(x[0,1]);
	return x[0,2,1];
}
+/
/+
def builder2(const a:ğ”¹) {
    def f2()const: ğ”¹{
        return a;
    }
    return f2;
}+/
/+
def main(){
	a:=(1:ğ”¹,H(0:ğ”¹),1:ğ”¹);
	i:=1:uint[2];
	measure(a[i]);
	return (a[i],a,i);
}
+/
/+
def foo[n:!â„•](x:!ğ”¹^n):!â„•â‡’n;

def main(){
	return foo(false,false,false);
}
+/

//import codeforces.winter19.contest.b1;

/+
def main(){
	i:=H(0:ğ”¹);
	x:=array(2,0:ğ”¹);
	x[0] = if i==0 then 1:ğ”¹ else 0:ğ”¹;
	k:=if x[0] then 0:ğ”¹ else 1:ğ”¹;
	return (x,i,k);
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	return ((measure(0)+1)+(x as int[3]),x); // TODO
}
+/
/+
def main(){
	x:=array(2,0:ğ”¹);
	i:=H(0:ğ”¹);
	x[i]=1:ğ”¹;
	forget(i=x[1]);
	return x;
}
+/
/+
def main(){
	x:=array(2,0:uint[2]);
	i:=H(0:ğ”¹);
	j:=H(0:ğ”¹);
	x[i][j]=1:ğ”¹;
	forget(i=if x[0][0]|x[0][1] then 0:ğ”¹ else 1:ğ”¹);
	forget(j=if x[0][0]|x[1][0] then 0:ğ”¹ else 1:ğ”¹);
	return x;
}
+/
/+
def main(){
	x:=array(2,vector(2,0:ğ”¹));
	i:=H(0:ğ”¹);
	j:=H(0:ğ”¹);
	x[i][j]=1:ğ”¹;
	forget(i=if x[0][0]|x[0][1] then 0:ğ”¹ else 1:ğ”¹);
	forget(j=if x[0][0]|x[1][0] then 0:ğ”¹ else 1:ğ”¹);
	return x;
}
+/

/+
def foo(const x:ğ”¹):!â„•{
	return if x then 0 else 1; // error
}
+/
/+
def solve(f: ğ”¹^2 !â†’lifted ğ”¹){
	x:=vector(1,0:!ğ”¹);
	return x==vector(1,0:ğ”¹);
}
def main(){
	g := Î»[n:!â„•](x: ğ”¹^n)liftedâ‡’0:ğ”¹;
	f := g[2];
	x:=solve(f);
	y:=solve(f);
	return (x,y);
}
+/
/+
def solve(f: ğ”¹^0 !â†’lifted ğ”¹){
	x:=vector(1,0:ğ”¹);
	return measure(x)==vector(1,0:ğ”¹);
}
def main(){
	g := Î»[n:!â„•](x: ğ”¹^n)liftedâ‡’0:ğ”¹;
	x:=solve(g[0]);
	return x;
}
+/
/+
def main(){
	x:=(1,2);
	//y:=H(0:ğ”¹) as int[2]; // TODO
	yb:=H(0:ğ”¹);
	y:=if yb then 1:int[2] else 0:int[2];
	forget(yb=if y==1 then 1:ğ”¹ else 0:ğ”¹);
	x[y]=3; // error
	return y;
}
+/
/+
def main(){
	x:=0:ğ”¹;
	forget(x=0);
}
+/
/+
def main(){
	n:=measure(H(0:ğ”¹)):!â„•;
	def foo(){
		x:=0:int[n];
		return x;
	}
	y:=0:int[n];
	n=3; // error
	x:=measure(foo()) as !â„¤;
	return x;
}
+/
/+import codeforces.summer18.contest.a3; // TODO: make compile without type annotation
def main(){
	return solve((false,true,true),(false,true,false));
}
+/

/+
def main(){
	x:=H(false);
	if x{
		y:=2:int[3];
	}else{
		y:=3:int[3];
	}
	forget(x=y==2);
	return y;
}
+/
/+
def main(){
	bits:=(true,false,true);
	x:=H(0:ğ”¹);
	if x { qsâ‚ := bits:ğ”¹^3; }else{ qsâ‚ := vector(3,0:ğ”¹); }
	qsâ‚‚ := if x then bits else vector(3,0:ğ”¹);
	forget(x=qsâ‚[0]);
	forget(qsâ‚‚=qsâ‚);
	return qsâ‚;
}
+/
/+
def main(){
	x:=2:!uint[10];
	y:=dup(x);
	(x[0],x[1])=(x[1],x[0]);
	return x;
}
+/
/+
def main(){
	x:=2:uint[10];
	(x[0],x[1]):=(x[1],x[0]);
	return x;
}
+/
/+
def main(){
	x:=0:!uint[10];
	x[5]=1:!ğ”¹;
	return x;
}
+/
/+
def main(){
	(x,a):=(0:ğ”¹,[1:ğ”¹]);
	(x,a[0]):=(a[0],x);
	return (x,a);
}
+/
/+
def main(){
	return H(reverse(reverse(H))(0:ğ”¹));
}
+/
/+
def main(){
	x:=vector(1,0:int[1]);
	x[0][0]:=H(x[0][0]);
	return x;
}
+/
/+
def solve[n:!â„•](bits: !ğ”¹^n){
	x:=H(0:ğ”¹);
	qs := if x then bits else (0:int[n]) as ğ”¹^n;
	forget(x=qs[0]);
	return qs;
}
// import codeforces.summer18.contest.a2;

def main(){
	return solve((1,0,0,1,0,1):!ğ”¹^6);
}
+/
/+
import codeforces.summer18.contest.a1;
def main(){
	return solve(3);
}
+/
/+
def main(){
	x:=0:int[1];
	x[0]:=H(x[0]);
	x[0]:=H(x[0]);
	return x;
}
+/
/+
def main(){
	x:=[]:ğ”¹[];
	y:=H(0:ğ”¹);
	x~=[y];
	x[0]:=H(x[0]);
	return x;
}
+/
/+
def main(){
	x:=vector(1,0:ğ”¹);
	x[0] := H(x[0]);
	x[0] := H(x[0]);
	return x;
}
+/
/+
def array2vec[n:!â„•][Ï„](a: Ï„[])qfree:Ï„^n{ // TODO
	assert(a.length==n);
	if n==0{ return (); } // TODO
	return array2vec[n div 2](a[0..n div 2])~array2vec[(n+1) div 2](a[n div 2..n]); // TODO
}
+/
/+
def main(){
	assert(1:!ğ”¹);
}
+/
/+
def main(){
	x:=dup((vector(3,1:ğ”¹) as int[3]) as ğ”¹^3);
	return x;
}
+/
/+
def main(){
	x:=(vector(3,1:ğ”¹) as int[3]) as ğ”¹^3;
	return x;
}
+/
/+
def main(){
	x:=((vector(3,1:ğ”¹) as int[3]) as ğ”¹^3):ğ”¹[];
	return x;
}
+/
/+
def main(){
	x:=(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16):int[4]^16;
	return x;
}
+/
/+
def main(){
	//x:=2:!int[2];
	//y:=x:!â„¤;
	x:=(0:int[3]);
	x[1]:=H(x[1]);
	y:=x as ğ”¹^3;
	return y;
}
+/
/+
def main(){
	x:=-3:int[3];
	x+=3;
	return x;
}
+/
/+
def main(){
	x:=0:int[2];
	y:=0:int[3];
	z:=x+y; // error
}
+/
/+
def f(const x:ğ”¹)liftedâ‡’dup(x);

def main(){
	y:=f(measure(H(0:ğ”¹)));
	//__show(__query("dep",y));
}
+/
/+
def foo(const x:ğ”¹){
	y:=0:ğ”¹;
	z:=1:ğ”¹;
	if x{
		return y;
	}else{
		return z;
	}
}

def main(){
	return foo(1:ğ”¹);
}
+/
/+
def main(){
	x:=0:ğ”¹;
	y:=0:ğ”¹;
	while(measure(H(0:ğ”¹))){ // error
		x=H(y);
	}
	return x;
}
+/
/+def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	while(measure(H(0:ğ”¹))){ // error
		forget(y);
	}
	return H(x);
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	while(measure(x)){
		forget(y=true);
		x:=H(0:ğ”¹);
		y:=dup(x);
	}
	return y;
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	while(measure(H(0:ğ”¹))){
		y:=dup(x);
	}
	return H(x);
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	if x{
		y:=dup(x);
	}else{
		z:=dup(x);
	}
	return H(x);
}
+/
/+def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	z:=measure(H(0:ğ”¹));
	if z{
		forget(y=dup(x));
	}
	return (z,H(x));
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	y:=0:ğ”¹;
	return (if x then y else H(y), x);
}+/
/+
def main(){
	x:=H(0:ğ”¹);
	for i in [0..10){
		y:=dup(x);
	}
	return x;
}
+/
/+def main(){
	x:=H(0:ğ”¹);
	repeat 10{
		y:=dup(x);
	}
	return H(x);
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	if true{
		y:=dup(x);
		//forget(y);
	}
	return H(x);
}
+/
/+def main(){
	x:=H(0:ğ”¹);
	if true{
		y:=dup(x);
		//forget(y=dup(x));
	}
	r:=H(x);
	return r;
}+/
/+
def main(){
	x:=0:ğ”¹;
	if x{ x:=X(x); } // error
}
+/
/+
def foo[n:!â„•](const a:int[n],b:int[n]){
	b+=a;
	return b;
}
def bar[n:!â„•](a:int[n]){
	foo(a,a); // error
	return a;
}
+/
/+
def add[n:!â„•](a:int[n],b:int[n]){
	return (a+b,a,b); // ok
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	xâŠ•=x;
	return (x,y);
}
+/

/+
def main(){
	x:=[H(0:ğ”¹)];
	y:=dup(x);
	return (x,y);
}
+/
/+
def main(){
	x:=[]:ğ”¹[];
	x:=x~[H(false)];
	y:=dup(x)~[H(false)];
	/*x~=[H(0:ğ”¹)];
	y:=dup(x);
	y~=[H(0:ğ”¹)];*/
	return (x,y);
}
+/
/+
def main(){
	x := 0: int[32];
	a := []: ğ”¹[];
	for i in [0..10){ a~=[H(false)]; }
	for i in [0..10){ x+=a[i]; }
	x:=measure(x);
	return a;
}
+/
/+
def main(){
	f:=(x:ğ”¹)qfreeâ‡’ x;
	x:=H(0:ğ”¹);
	y:=dup(x);
	z:=f(y);
	forget(z);
	y:=dup(x);
	z:=dup(f(y));
	forget(z);
	a:=0:!ğ”¹;
	b:=f(a);
	b=a;
	return x;
}
+/
/+
def solve(){
	(qâ‚€,qâ‚):=(1:ğ”¹,1:ğ”¹);
	while measure(qâ‚€&qâ‚){
		measure(qâ‚€,qâ‚);
		(qâ‚€,qâ‚):=(H(0:ğ”¹),H(0:ğ”¹));
	}
	return (qâ‚€,qâ‚);
}
+/
/+
def main(){
	Ï†:=2*asin(0.5);
	return rotY(Ï†,0:ğ”¹);
}
+/
/+def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	y=0:ğ”¹;
	return H(x);
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	if true{
		y:=dup(x);
	}
	return H(x); // TODO: âˆ£0âŸ©
}
+/
/+def main(n:!â„•){
	qs:=vector(n,vector(n,0:ğ”¹));
	def f[a](x:a)â‡’x;
	for i in [0..n){
		for j in [0..n){
			(qs[i],qs[j]):=(qs[j],qs[i]);
		}
	}
}
+/
/+
def solve(n:!â„•){
	qs:=vector(n,0:ğ”¹);
	for i in [0..n){ qs[i]:=H(qs[i]); }
	return qs;
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	y:=dup(x);
	z:=dup(y);
	forget((y,z)=(x,x));
	y:=dup(x);
	z:=dup(y);
	forget(y,z);
	forget(H(x)=0:ğ”¹);
}
+/
/+
def main(){
	f:=[a]â‡’reverse(dup[a]);
	f=3;
}
+/
/+
def main(){
	def id(x:ğ”¹)liftedâ‡’dup(x);
	x:=H(0:ğ”¹);
	id(x);
	x:=H(x);
	return x;
}
+/
/+
def main()qfree{
	def foo(x:ğ”¹,const y:ğ”¹)qfreeâ‡’x;
	return reverse(foo)(0:ğ”¹,0:ğ”¹);
}
+/
/+
import grover;
def main()â‡’grover((x:uint[6])liftedâ‡’x==42);
+/
/+def main(){
	return 2 sub 1;
}+/
/+
import conv;
def main(){
	x:=vector(3,0:ğ”¹);
	for i in [0..3){ x[i]:=H(x[i]); }
	for i in [0..round(Ï€/4*sqrt(2^3))){
		if ([n:!â„•]â‡’reverse(toVecU[n]))(dup(x))==5{ phase(Ï€); }
		for k in [0..3){ x[k]:=H(x[k]); }
		if ([n:!â„•]â‡’reverse(toVecU[n]))(dup(x))==0{ phase(Ï€); }
		for k in [0..3){ x[k]:=H(x[k]); }
	}
	return measure(toUint(x));
}
+/
/+
import conv;
def main(){
	x:=vector(3,0:ğ”¹);
	for i in [0..3){ x[i]:=H(x[i]); }
	for i in [0..round(Ï€/4*sqrt(2^3))){
		if toUint(dup(x))==5{ phase(Ï€); }
		for k in [0..3){ x[k]:=H(x[k]); }
		if toUint(dup(x))==0{ phase(Ï€); }
		for k in [0..3){ x[k]:=H(x[k]); }
	}
	return measure(toUint(x));
}
+/
/+
def main(){
	x:=0:uint[3];
	for i in [0..3){ x[i]:=H(x[i]); }
	for i in [0..floor(Ï€/4*sqrt(2^3))){
		if x==5{ phase(Ï€); }
		for k in [0..3){ x[k]:=H(x[k]); }
		if x!=0{ phase(Ï€); }
		for k in [0..3){ x[k]:=H(x[k]); }
	}
	return measure(x)==5;
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	def f(g: ğ”¹â†’qfree ğ”¹)qfree{
		return g(x);
	}
	return H(f((x:ğ”¹)qfreeâ‡’x));
}
+/
/+
def id[a](x:a)qfreeâ‡’x;

def main(){
	//x:=([a]qfreeâ‡’reverse(id[a]))(id);
	//f:=id;
	y:=0:ğ”¹;
	x:=id(y);
	//__show(__query("dep",x));
}
+/
/+
def uniform_entangle[n:!â„•](bits:(!ğ”¹^n)^4)mfree{
    anc:=0:int[2];
    for j in [0..2){ anc[j]:=H(anc[j]); }
	qs:=vector(n,false:ğ”¹);

    for i in [0..n-1] {
        for a in [0..3] {
            if anc == a && bits[a][i] {
                qs[i] := X(qs[i]);
            }
        }
    }
    return (anc, qs);
}

def rev_entangle[n:!â„•](bits:(!ğ”¹^n)^4, r:int[2]Ã—ğ”¹^n)mfree{
	(anc,qs) := r;
    for i in [n - 1..-1..0]{
        for a in [3..-1..0]{
            if anc = a && bits[a][i] {
                qs[i] := X(qs[i]);
            }
        }
    }
    forget(qs=vector[ğ”¹](n,0: ğ”¹));
    for j in (2..-1..0]{
        anc[j] := H(anc[j]);
    }
    forget(anc=0: int[2]);
    return ();
}

def solve[n:!â„•](bits:(!ğ”¹^n)^4) {
    (anc, qs) := uniform_entangle(bits);
    //result := dup(qs);
    reverse(uniform_entangle[n])(bits, (anc, qs));
	//rev_entangle(bits, (anc, qs));
    //return result;
}

def main(){
	return solve(((0,0,0),(1,0,0),(0,1,0),(0,0,1)):!(ğ”¹^3)^4);
}
+/
/+
def solve[n:!â„•](bits:(!ğ”¹^n)^4){
    anc:=0:uint[2];
    for j in [0..2){ anc[j]:=H(anc[j]); }
    qs:=(bits:(ğ”¹^n)^4)[anc];
	for j in [0..3] {
		if qs==bits[j]{
			ancâŠ•=j;
		}
	}
	forget(anc=0:uint[2]);
    return qs;
}
def main()â‡’solve(((0,0,0),(1,0,0),(0,1,0),(0,0,1)):!(ğ”¹^3)^4);
+/
/+
def main(){
    anc:=0:int[1];
    for j in [0..1){ anc[j]:=H(anc[j]); }
	for j in [0..1){ anc[j]:=H(anc[j]); }
    return forget(anc=0: int[1]);
}
+/
/+
def main(){
	/+x:=0:!int[3];
	x[0]=!x[0];
	x[1]=1:!ğ”¹;+/
	y:=0:int[3];
	//y[0]:=H(y[0]);
	y[0]=1:ğ”¹;
	//return (x,y);
	return y;
}
+/
/+
def solve[n:!â„•](f: ğ”¹^n !â†’lifted ğ”¹){
	x:=0:int[n];
	for i in [0..n){ x[i] := H(x[i]); }
	if f(x as ğ”¹^n){ phase(Ï€); }
	for i in [0..n){ x[i] := H(x[i]); }
	return measure(x)==0;
}
//import codeforces.summer18.warmup.i;
def main(){
	f := Î»[n:!â„•](x: ğ”¹^n)lifted{
		r:=0:ğ”¹;
		for i in [0..n){
			râŠ•=x[i];
		}
		return r;
	};
	g := Î»[n:!â„•](x: ğ”¹^n)liftedâ‡’0:ğ”¹;
	x:=solve(f[1]);
	y:=solve(g[1]);
	return (x,y);
}
+/
/+
def solve[n:!â„•](f: ğ”¹^n !â†’lifted ğ”¹){
	x:=vector(n,0:ğ”¹);
	for i in [0..n){ x[i] := H(x[i]); }
	if f(x){ phase(Ï€); }
	for i in [0..n){ x[i] := H(x[i]); }
	return measure(x)==vector(n,0:!ğ”¹);
}
//import codeforces.summer18.warmup.i;
def main(){
	f := Î»[n:!â„•](x: ğ”¹^n)lifted{
		r:=0:ğ”¹;
		for i in [0..n){
			râŠ•=x[i];
		}
		return r;
	};
	g := Î»[n:!â„•](x: ğ”¹^n)liftedâ‡’0:ğ”¹;
	x:=solve(f[1]);
	y:=solve(g[1]);
	return (x,y);
}
+/
/+def solve(f: ğŸ™ !â†’ ğŸ™){
	return (0:!ğ”¹)==(0:ğ”¹);
}
def main(){
	g := Î»()()â‡’();
	x := solve(g());
	y := solve(g());
	return (x,y);
}
+/
/+
def main():!ğ”¹Ã—!ğ”¹{
	a:=vector(1,0:!ğ”¹);
	x:=a==vector(1,0:!ğ”¹);
	b:=vector(1,0:!ğ”¹);
	y:=b==vector(1,0:!ğ”¹);
	return (x,y);
}
+/
/+
def solve(f: ğ”¹^1 !â†’lifted ğ”¹){
	x:=vector(1,0:!ğ”¹);
	return x==vector(1,0:ğ”¹);
}
def main(){
	g := Î»[n:!â„•](x: ğ”¹^n)liftedâ‡’0:ğ”¹;
	x := solve(g[1]);
	y := solve(g[1]);
	return (x,y);
}
+/
/+
def main(){
	n:=10;
	y:=measure(H(0:ğ”¹),H(0:ğ”¹),H(0:ğ”¹),H(0:ğ”¹),H(0:ğ”¹),H(0:ğ”¹),H(0:ğ”¹),H(0:ğ”¹),H(0:ğ”¹),H(0:ğ”¹));
	x:=vector(10,0:ğ”¹);
	for i in [0..n){ x[i]:=H(x[i]); }
	r := 0:ğ”¹;
	for i in [0..n){ râŠ•=x[i]&y[i]; }
	if r { phase(Ï€); }
	forget(r);
	for i in [0..n){ x[i]:=H(x[i]); }
	assert(measure(x)==y);
}
+/
/+
def main(){
	n:=4;
	applyPhase:=measure(H(0:ğ”¹));
	x:=vector(4,0:ğ”¹);
	for i in [0..n){ x[i]:=H(x[i]); }
	r := 0:ğ”¹;
	for i in [0..n){ râŠ•=x[i]; }
	if r&&applyPhase { phase(Ï€); }
	forget(r);
	for i in [0..n){ x[i]:=H(x[i]); }
	return (applyPhase,measure(x)==vector(4,0:!ğ”¹)); // TODO: correct type for vectors and tuples
}+/

/+
def main(){
	x:=(0,1,1,0):ğ”¹^4;
	i:=0:int[2];
	i[0]:=H(i[0]); // TODO
	i[1]:=H(i[1]);
	r:=x[i];
	return (x,r,i);
}
+/
/+import codeforces.summer18.warmup.h;
def main(){
	x := (1,0,1,0,1):ğ”¹^5;
	r := solve(x);
	return (x,r);
}
+/
/+
import codeforces.summer18.warmup.g;
def main(){
	x:=(0,0,1,0,1):ğ”¹^5;
	return solve(x,3);
}
+/
/+
def main(){
	x:=(0,1,1,0):ğ”¹^4;
	x[0]:=H(x[0]);
	return x;
}
+/
/+
def main(){
	x:=(0,1,1,0):ğ”¹^4;
	a:=0:ğ”¹;
	(a,x[0]):=(x[0],a);
	a:=H(a);
	(a,x[0]):=(x[0],a);
	forget(a=(0:ğ”¹));
	return x;
}
+/
/+
def main(){
	x:=(0,1,1,0):ğ”¹^4;
	x[0]=1:ğ”¹;
	return x;
}
+/

/+
def id[Ï„:*](const x:Ï„)liftedâ‡’dup(x);

def main(){
	return id(0:ğ”¹);
}
+/
/+
def sum[n:!â„•](const a:int[32]^n)lifted{
	r:=0:int[32];
	for i in [0..n){
		r+=a[i];
	}
	return r;
}

def add(n:!â„•,const x:int[32])lifted{
	r:=0:int[32];
	for i in [0..n){
		r+=x;
	}
	return r;
}

def main(){
	b := H(0:ğ”¹);
	a := vector(10,b as int[32]); // TODO
	r:=add(10,sum(a));
	return (a,b,r);
}
+/
/+def main(){
	a := 0:ğ”¹;
	b:=dup(dup(dup(dup(dup(a))))); // TODO: use only two variables
	measure(a,b);
	x:=0;
}
+/
/+
def sum(const a:int[32])lifted{
	//r:=dup(a);
	r:=0:int[32];
	r+=a;
	return r;
}

def main(){
	b := H(0:ğ”¹);
	a := dup(b as int[32]); // TODO
    r:=sum(sum(sum(a)));
	return measure(a,b,r);
}
+/
/+
def main(){
	b:=H(0:ğ”¹);
	a:=dup(b);
	return (a,b);
}
+/
/+
def main(){
	b := H(0:ğ”¹);
	x := b as int[32]; // TODO
	return x;
}
+/
/+
def main(){
	b:=H(0:ğ”¹);
	a:=dup(b as int[32]); // TODO
	measure(a,b);
	x:=0;
}
+/
/+
def sum(const a:int[32])lifted{
	//r:=0:int[32];
	//r+=a;
	r:=dup(a);
	return r;
}

def main(){
	b := H(0:ğ”¹);
	a := dup(b as int[32]); // TODO
	r:=sum(a);
	measure(a,b,r);
	x:=0;
}
+/
/+
def f(t:int[32]){
	return t;
}

def main(){
	a := 0:int[32];
	b := 1:int[32];
	x := f(a+b);
	forget(a=(0:int[32]));
	forget(b=(1:int[32]));
	return x;
}
+/
/+
def f()liftedâ‡’0:int[32];
def main(){
	y:=f()+f();
	return (y);
}
+/
/+
def main(){
	x := H(0:ğ”¹);
	f := dup(()â‡’x); // error
}
+/
//def f[a,b,c](x:a,y:b,z:c)â‡’(x,y,z);
/+
def geom(){
	if measure(H(0:ğ”¹)){ return 0; }
	return 1+geom();
}

def main(){
	return geom();
}
+/
/+
def main(){
	x:=0;
	forget(x);
	return x; // TODO: error?
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	z:=H(0:ğ”¹);
	fyâ‚:=lambda(const z:ğ”¹)liftedâ‡’dup(z);
	fyâ‚‚:=lambda(const z:ğ”¹)liftedâ‡’!z;
	fyâ‚ƒ:=lambda(const x:ğ”¹,const z:ğ”¹)liftedâ‡’if x then fyâ‚(z) else fyâ‚‚(z);
	if x{
		y:=dup(z);
	}else{
		y:=!z;
	}
	//y:=if x then dup(z) else !z;
	forget(y=fyâ‚ƒ(x,z));
	return (x,z);
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	if true{
		y:=dup(x);
		forget(y);
	}
	x:=H(x);
	return x;
}
+/
/+
def main(){
	x:=H(0:ğ”¹);
	def f(x:ğ”¹)â‡’H(x);
	y:=x;
	y:=f(y);
	return y;
}
+/
/+
def main(){
	x:=1:ğ”¹;
	if x{
		def f[a,b,c](x:a,y:b,z:c)â‡’(x,y,z);
		return (1,2,3);
	}else{
		return (2,3,4);
	}
}
+/
/+def main(){
	x:=vector(3,0:ğ”¹);
	//x[0]:=H(x[0]);
	return x[1];
}
+/

/+
import codeforces.summer18.warmup.f;
def main(){
	x:=vector(3,0:ğ”¹);
	x[1]:=X(x[1]);
	bits:=vector(2,vector(3,0:!ğ”¹));
	bits[0][1]=1:!ğ”¹;
	r:=solve(x,bits);
	measure(x);
	return r;
	//return solve((0,1,0):ğ”¹^3,((0,1,0),(1,0,1)):(ğ”¹^3)^2); // TODO!
}
+/
/+
import codeforces.summer18.warmup.d;

def main(){
	assert(solve(H(0:ğ”¹))==1);
	assert(solve(H(1:ğ”¹))==-1);
}
+/
/+
def fib(f: !â„• !â†’ !â„•)(n:!â„•){
	if n<=1{ return n; }
	return f(n sub 1)+f(n sub 2);
}

def fix[a](f: (a!â†’a)!â†’(a!â†’a)){
	def g(x:a):aâ‡’f(g)(x); // TODO
	return g;
}
def main(){
	return fix(fib)(10);
}
+/
/+
def fib(n:!â„•):!â„•{
	if n<=1{ return n; }
	return fib(n sub 1)+fib(n sub 2);
}
def main(){
	return fib(10);
}
+/

/+def main(){
	//x := [1,2,3:!â„];
	x := vector(3,1);
	y := x;
	r := 0:!â„;
	for i in [0..3){
		r+=y[i];
	}
	return r;
}
+/
/+
def add(x:!â„,y:!â„){
	return x+y;
}

def main(){
	//x := H(0:ğ”¹);
	//return measure(x);
	x:=1;
	y:=[2.2];
	//return add(1,2);
	return add(x,y[0..1][0]);
}
+/
/+
def todo[n:!â„•](const x:uint[n]){
	t := (0,0):(uint[n]Ã—uint[n]);
	t[0] = dup(x):uint[n];
	__show(__query("dep",t)); // {x}
	return t;
}
+/
/+def sum[n:!â„•](const x:uint[n][],const y:uint[n])mfree:uint[n]{
	s := dup(y): uint[n];
	for i in [0..x.length){
		s = s + x[i];
	}
	__show(__query("dep",s));
	return s;
}
+/
/+
def bad[n:!â„•](x:uint[n])mfree{
	s := x;
	s -= s; // error
	return s;
}
+/
/+
def bad[n:!â„•](x:uint[n])mfree{
	s := 0: uint[n];
	s = x;
	s = 0; // error
	return s;
}
+/
/+
def f(const a:ğ”¹[],x:ğ”¹,y:!ğ”¹):ğ”¹{
	if y{
		x := H(x);
	}
	return x;
}
def main(n:!â„•){
	a := array(n,0:ğ”¹);
	a[0] := f(a,a[0],true); // error
	return a;
}
+/

/+
def main[n:!â„•](a: ğ”¹[], i: int[n]){
	x := a[i];
	forget(x); // TODO: don't require this
	return (a,i);
}
+/
/+def f[a](const b: a[])[b](const c: b[]){

}+/
/+
def f[a:*,n:!â„•]: Î (const b: a^n). 1{
	return (const b: a^n){

	}
}

A â†’ B

Î (_: A). B

(const A) â†’ B

Î (const _: A). B.

def grover[n](f: Î (const x: uint[n]). ğ”¹){

}

def main(){
	f(x);
	x := 2;
	y := []: â„^x;
}
+/

/+
def f(const x:ğ”¹)lifted{
	phase(Ï€); // error
	return ();
}

def main(){
	x := f(0:ğ”¹);
	forget(x=f(0:ğ”¹));
}
+/
/+def abc(){
    b := f(cand);
    if b{
        phase(Ï€);
    }
    forget(b=f(cand));
}
+/
/+
def main(){
	//x := 0:!â„¤;
//repeat 10 { x -= 2; }
//return 2.0*Ï€*2^(-1);
x := 2.0^-1;
x = "";
}
+/
	/+
	def main(){
		x := 1:ğ”¹;
		if x {
			return 1:ğ”¹; // TODO: this should be an error!
		}
		return x;
	}
+/
	/+
	def main(x:ğ”¹^5){
		//x := 0:int[5];
		return x[x:int[5]];
	}
+/
	/+
	def main(){
		x := false:ğ”¹;
		if x{
			z := H(false):ğ”¹;
		}
	}
+/
	/+
	def flipWith_Array[l:!N](const p:ğ”¹^l, q:ğ”¹^l) mfree : ğ”¹^l {
		for i in[0..l) {
			if p[i] { q[i] := X(q[i]); }
		}
		return q;
	}

def a8_FetchT_Array[n:!N, rr:!N, r:!N](const i:int[r], const tt:int[n]^rr) : int[n] {
	ttd := 0:int[n];
	for j in [0..rr) {
		if i == j {
			ttd := flipWith_Array(tt[j]:B^n, ttd:B^n):int[n];
		}	}
	return ttd;
}
+/

/+def flipWith_Array[l:!N](const p:ğ”¹^l, q:ğ”¹^l)mfree : ğ”¹^l {
	for i in[0..l) {
		if p[i] { q[i] := X(q[i]); }
	}
	return q;
}

def a8_FetchT_Array[n:!N, rr:!N, r:!N](const i:int[r], const tt:int[n]^rr) : int[n] {
	ttd := 0:int[n];
	for j in [0..rr) {
		if i == j {
			ttd := flipWith_Array(tt[j]:B^n, ttd:B^n):int[n];
	}	}
	return ttd;
}
+/

/+
def a12_FetchStoreE[rr:!N,r:!N](const i:int[r], qs: (ğ”¹^rr)^rr,
	ps: ğ”¹^rr) : (ğ”¹^rr)^rr x ğ”¹^rr {

	for j in [0..rr) {
		for l in [0..j) {
			if i == j { (qs[j][l], ps[l]) := (ps[l], qs[j][l]); }
			if i == l { (qs[j][l], ps[j]) := (ps[j], qs[j][l]); }
		}
	}
	return (qs, ps);
}
+/
/+
def main(){
	y := 0:ğ”¹;
	x := dup(y);
	//forget(y=measure(x)+1);
	z := measure(H(false));
	//forget(y=x);
	//return x;
}
+/

/+
def main(x: ğ”¹){
	y := dup(x);
	x := H(x);
	return x;
}
+/
/+def main(x: ğ”¹)lifted{
	y := dup(x); // TODO: ok
	return x;
}
+/


/+def Node[k:!â„•]lifted â‡’ int[k];

def edgeOracle_spec[k:!â„•]lifted â‡’ ((const int[k] x const int[k] x ğ”¹) !-> ğ”¹);

def QWTFP_spec[k:!â„•]lifted â‡’ (!N x !N x edgeOracle_spec[k]);

def a5_SETUP[k:!â„•](oracle:!QWTFP_spec[k], const tt:int[2^oracle[1]]) : (ğ”¹^(2^oracle[1]))^(2^oracle[1]) {
    (n, r, edgeOracle) := oracle;
    rr := 2^r;
    ee := vector(2^oracle[1], vector(2^oracle[1], false:ğ”¹));

    // Todo: CHECK INDICES!
    for k in [0..2^r) {
        for j in [0..2^r) {
            ee[k][j] := edgeOracle(tt[j], tt[k], ee[k][j]);
    }    }

    return ee;
}
+/
/+
def a4_Hadamard_Array[k:!N](q:ğ”¹^k) : ğ”¹^k {
    for j in [0..k) { q[j] := H(q[j]); }
    return q;
}

def a4_Hadamard_Array_Array[k:!N,l:!N](q:(ğ”¹^k)^l) : (ğ”¹^k)^l {
    for i in [0..l) {
        q[i] := a4_Hadamard_Array(q[i]);
    }
    return q;
}

// -------------------------------------------------------------

def a7_Diffuse_Array[k:!N](q:ğ”¹^k) : ğ”¹^k {
    q := a4_Hadamard_Array(q);
    if q == array(k,false) { phase(Ï€); }
    q := a4_Hadamard_Array(q);
	return q;
}

// -------------------------------------------------------------

def flipWith_Array[l:!N](const p: ğ”¹^l, q:ğ”¹^l) : ğ”¹^l {
    for i in[0..l) {
        if p[i] { q[i] := X(q[i]); }
    }
    return q;
}
+/


/+def QFT[n:!N]lifted(psi:uint[n]) mfree: uint[n];

def inverse[Ï„,Ï‡]lifted(f: Ï„ !â†’ mfree Ï‡)lifted(x:Ï‡)mfree â‡’ reverse(Î»(x:Ï„,const _:ğŸ™)mfree. f(x))(x,());

def PeriodFinding[n:!N](f:!(uint[n] -> lifted uint[n])):!N{
    cand := 0:uint[n];
    //for k in [0..n) { cand[k] := H(cand[k]); }
    ancilla := f(cand);
	cand := inverse(QFT[n])(cand);
    measure(ancilla);
    return measure(cand):!N;
}
+/
/+
def main(){
	x := 0: !int[100];
	//x[0]âŠ•=1:ğ”¹;
	x[1]=1:!ğ”¹;
}
+/
/+
def main(){
	c := H(false);
	if c{
		//x := H(false);
		y := [dup(c),1,2];
	}else{
		//x := H(true);
		y := [dup(c),2];
	}
	c:=H(c);
	forget(c=false);
	return y;
}
+/
/+
def id[x](a:x):x;

def main(){
	x := id(2);
}
+/
/+
def main[n:!â„•](x: ğ”¹^n){
	//y := x[1];
	y := x;
	y[1] := true;
	return (y);
}
+/

/+
def zero(n:!â„•):int[n]{
	return 0:int[n];
}+/

/+
def main(){
	x := 0: int[64];
	//y := true : !ğ”¹;
	y := x+1:â„•;
	//z := measure(y);
	//forget(x=z-1);
}
+/

/+
def f[k:!â„•](x: int[k]){
	return x;
}

def main(i: int[32]){
	return f(i);
}
+/


/+
def main(x:â„•){
	f := Î»(a:ğŸ™,const b:ğŸ™)mfree. x;
	g := dup(f);
	reverse[ğŸ™,ğŸ™,â„•](f)(g((),()),());
}
+/
/+
def main(x:â„•){
	y := H(false);
	f := Î»(x:â„•,const _:ğŸ™)mfree.{
		y := y;
		xpy := x+y;
		forget(x=xpy-y);
		return (xpy,y);
	};
	return reverse[â„•,ğŸ™,â„•Ã—ğ”¹](f)((x,H(false)),());
}
+/
/+
def main(x:ğ”¹){
	if x{
		y := H(x);
	}else{
		y := H(X(x));
	}
	return y;
}
+/
/+
def main(x:ğ”¹){
	if x{
		measure(x);
	}else{
		measure(x);
	}
}
+/
/+
def main(){
	x := reverse;
	x = 2;
}
+/
/+
def f(x: ğ”¹, y: !ğ”¹){
	return x;
}

def main(){
	x := (true:ğ”¹,false:!ğ”¹);
	return f(x);
}
+/

/+
def f(const x: ğ”¹, const y: ğ”¹)lifted{
	a:=(dup(x),1);
	return (dup(x),a);
}
+/
/+
def f(const x: ğ”¹)lifted{
	y := x;
	return ()=>y;
}
+/
/+
def f(const x: ğ”¹){
	y := x;
	return y;
}
+/
/+
def f(const x: ğ”¹){
	f:=()=>x;
	return f;
}
+/
/+
def CNOT(x:ğ”¹,const y:ğ”¹){
	return (x,y);
}

def main(){
	k := (false,false): ğ”¹Ã—ğ”¹;
	return CNOT(k);
}
+/
/+
def main(x: ğ”¹){
	x := x;
	return (){ x:=x; y:=x+1; forget(x=y-1); return y; }
}
+/

/+def main(const x: ğ”¹){
	return x+1;
}
+/
/+def main(const x: ğ”¹){
	return ()â‡’x+1;
}
+/

/+
def main(const x: ğ”¹){
	def f(){ def g()â‡’x; return g; }
	return f;
	//return ()=>x;
}
+/

/+
def main(){
	x := false:!ğ”¹;
	def f(){ return x; }
	y := x;
	return (f(),f());
}
+/
/+
def main(){
	x := false:ğ”¹;
	f := ()=>x;
	//def f(){ return x; }
	y := x; // error
	//return f;
	return (f,f); // error
}
+/
/+
def main():!(â„•[]){
	return dup[â„•[]]([1,2,3]):!â„•[];
}
+/
/+
def main():!â„•Ã—!â„•{
	return dup[â„•Ã—â„•](1,2);
}
+/
/+def main():!â„•{
	return dup[â„•](1);
}
+/
/+def main(){
	f := lambda(x:â„)lifted. { return x; };
	x:=2;
	return f(x);
}
+/
/+def main(x: ğ”¹)mfree{
	measure(x);
}
+/

/+def foo()mfree:â„•{
	n := 0:â„•;
	if H(false){
		n+=foo();
	}
	return n;
}
+/

/+def main(){

}+/

/+
def main(x: ğ”¹,y: ğ”¹){
	return H(x)||H(y);
}
+/
/+
def main(x: ğ”¹)mfree{
	y := dup(H(x));
	return y;
}
+/
/+def main(x: ğ”¹){
	if measure(dup(x)){
		y:=H(x);
	}else{
		y:=H(x);
		//y := H(true);
		//measure(x);
		//forget(x=z);
		//z := H(x);
	}
    return y;
}
+/
/+
def main(x: !ğ”¹){
	/+f := lambda(i:const â„•, ee:ğ”¹[][]) . {
		return (ee, tt);
	};+/
	y := 3;
	return x;
}
+/
/+def main(){
	if !x{

	}
	if !(triTestT == 0 && triTestTw == 0) {
		phase(pi);
	}
}
+/

/+
rbar := 5;

def f(const x:ğ”¹){
	y := x;
	//if measure(x){ y:=hadamard(y); } // TODO: error
	if x{ y:=hadamard(y); } // TODO: ok
	return y; // TODO: ok
}

def main(){
	a := hadamard(false);
	b := hadamard(false);
	return f(a&&b);
}
+/

/+
//x:=2;

def main(const n: !Int[32],b:!â„¤)lifted:ğŸ™{
	x := false:ğ”¹;
	x := H(x):ğ”¹;
	//y := main : !Int[32]Ã—!ğ”¹ â†’lifted ğŸ™;
	//y := main : Î (consumed n: Int[32],x: !ğ”¹). lifted ğŸ™;
	//y := main: const Int[32] Ã— !ğ”¹ â†’mfree ğŸ™;
	m := n: Int[32];
	def foo(f: !(ğ”¹ â†’ ğ”¹)){
		return f: (ğ”¹ â†’ ğ”¹);
	}
	/+y = 2;
	if x{

	}+/
}
+/
