// implementation of Shor's algorithm for discrete log
// following https://www.cs.umd.edu/~amchilds/teaching/w08/l02.pdf

p:=17;      // Fermat prime modulus for â„¤^*_p
N:=p sub 1; // size of cyclic group (note: has to be power of two)
n:=4;       // logâ‚‚ N.

// compute Î´=dlog_g(x), i.e., g^Î´=x, for some generator g of â„¤^*_p.
def dlog(g:!â„•,x:!â„•){
	while true{
		(Î±,Î²):=(uniformSuperposition[n](N),uniformSuperposition[n](N));
		measure(powm(x as uint[n+1],Î±)Â·powm(g as uint[n+1],(N as uint[n])-Î²)%p);
		(Î¼,Î½):=measure(QFT(Î±),QFT(Î²)) as !â„•^2;
		(d,iÎ½):=egcd(Î½,N);
		if d=1{ return -Î¼*iÎ½%N; }
	}
}

def main()â‡’dlog(3,3^13%p);


// pad x with b zero bits
def pad[a:!â„•](x:uint[a],b:!â„•)qfreeâ‡’((x as ğ”¹^a)~vector(b,0:ğ”¹)) as uint[a+b];

// compute a^b%p
def powm[n:!â„•,m:!â„•](a:uint[n],b:uint[m])lifted: uint[2Â·n]{
	(r,x):=(1:uint[2Â·n], pad(a,n));
	for i in 0..m{
		if b[i]{
			r=rÂ·x%p;
		}
		x=xÂ·x%p;
	}
	return r;
}

// generate uniform superposition of |0âŸ©,â€¦,|N-1âŸ©
def uniformSuperposition[n:!â„•](N:!â„•){
	while true {
		x:=0:uint[n];
		for i in 0..n{ x[i]:=H(x[i]); }
		if measure(x<N){ return x; }
		measure(x);
	}
}

// QFT for â„¤_(2^n).
def QFT[n:!â„•](Ïˆ: uint[n])mfree: uint[n]{
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	for k in [0..n){
		Ïˆ[k] := H(Ïˆ[k]);
		for l in [k+1..n){
			if Ïˆ[l] && Ïˆ[k]{
				phase(2Â·Ï€ Â· 2^(k-l-1));
			}
		}
	}
	return Ïˆ;
}

// compute d=gcd(a,b) and k with aÂ·k â‰¡ d (mod b)
def egcd(a:!â„¤,b:!â„¤){
	(x,y,u,v):=(a,b,1,0):!â„¤^4;
	while yâ‰ 0{
		(x,y,u,v)=(y,x%y,v,u-(x div y)Â·v);
	}
	return (x,u);
}
