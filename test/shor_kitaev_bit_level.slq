def main(){
	n:=323;
	r:=shor(n);
	assert(1<râˆ§r<n);
	assert(n%r=0);
	return r;
}

def shor(n:!â„•){
	if n%2=0 { return 2; }
	(x,y):=asPower(n);
	if y>1{ return x; }
	while true{
		a:=2+uniform(n sub 2);
		d:=gcdn(a,n);
		if dâ‰ 1{ return d; }
		r:=order(a,n);
		k:=gcdn(powm(a,r div 2,n)+1,n);
		if 1<kâˆ§k<n { return k; }
	}
}

def asPower(n:!â„•){
	y:=2;
	while 3^yâ‰¤n{
		(l,r):=(0,1);
		while r^yâ‰¤n{ r*=2; }
		while l+1â‰ r{
			m:=(l+r) div 2;
			if m^yâ‰¤n { l=m; }
			else { r=m; }
		}
		if l^y=n{ return (l,y); }
		y+=1;
	}
	return (n,1);
}

def uniform(n:!â„•){
	(k,l):=(0,1);
	while lâ‰¤n { k+=1, l*=2; }
	while true {
		x:=0:!uint[k];
		for i in 0..k{ x[i]=measure(H(0)); }
		x:=x as !â„•;
		if x<n{ return x; }
	}
}

def order(a:!â„•,N:!â„•){
	(d,a_inv):=egcd(a,N);
	a_inv%=N;
	assert(d=1);
	(n,m):=(0,1);
	while m<N { n+=1, m*=2; }
	(aps,ais):=([a],[a_inv]);
	for i in 1..2Â·n+1{
		aps~=[aps[i-1]^2%N];
		ais~=[ais[i-1]^2%N];
	}
	b:=1;
	while powm(a,b,N)â‰ 1{
		def f[pw2:!â„•](b:uint[n]){
			nb:=mul_mod(b,aps[pw2],N);
			mul_mod(nb,ais[pw2],N):=b;
			return nb;
		}
		(Î¸,x):=estimatePhase[2Â·n+1](f,1:uint[n]);
		measure(x);
		c:=candidates((Î¸ as !â„•)/2^(2Â·n+1));
		for i in (c.length..-1..0]{
			if c[i]â‰ 0âˆ§powm(a,c[i],N)=1{ b=c[i]; }
		}
	}
	return b coerce !â„•;
}


def add_with_carry[n:!â„•](i:!â„•,const c:ð”¹,const a:ð”¹[],b:ð”¹^n)qfree: ð”¹^n{
	(bh,)~b:=b;
	if a[i] { bh:=X(bh); }
	if nâ‰ 1{ b:=add_with_carry(i+1,if bh then c else a[i],a,b); }
	if c { bh := X(bh); }
	return (bh,)~b;
}
def adder[n:!â„•](const a:ð”¹^n,b:ð”¹^n)qfree â‡’ add_with_carry(0,0:ð”¹,a,b);

def add[n:!â„•](b:uint[n],const a:uint[n]){
	return adder(a as ð”¹^n, b as ð”¹^n) as uint[n];
}


def add_mod[n:!â„•](b:uint[n],const a:!â„•,const N:!â„•){
	assert(a<N);
	x:=b>=N-a;
	b:=add(b,if x then a-N as uint[n] else a as uint[n]);
	forget(x=(b<a));
	return b;
}


def mul_mod[n:!â„•](const b:uint[n],const a:!â„•,const N:!â„•){
	r:=0:uint[n];
	/+for i in 0..n{ // TODO
		if b[i] {
			r:=add_mod(r,(aÂ·2^i)%N,N);
		}
	}
	return r;+/
	def rec(r:uint[n],i:!â„•)qfree{
		if i=n{ return r; }
		if b[i] { r:=add_mod(r,(aÂ·2^i)%N,N); }
		return rec(r,i+1);
	}
	return rec(0:uint[n],0);
}

def estimatePhase[n:!â„•][a:qtype](const f:Î [pw2:!N]qfree. a ->mfree a, arg:a): !uint[n]Ã—a{
	x_tilde:=0:!uint[n];
	for i in 0..n{
		bit:=H(0);
		if bit {
	        pw2:=n sub 1 sub i;
			arg:=f[pw2](arg);
			phaseU(2^pw2Â·-x_tilde);
		}
		bit:=H(bit);
		x_tilde[i]=measure(bit);
	}
	return (x_tilde,arg);
}

def phaseU[n:!â„•](const x:!uint[n]) {
	phase(2Â·Ï€Â·(x as !N)/2^n);
}

def candidates(q:!â„š):!â„•[]{
	if q=0{ return [0]; }
	assert(q>0);
	(r,x):=([],1/q);
	(qm2,qm1):=(1,0);
	while xâ‰ 0{
		x=1/x;
		a:=floor(x) coerce !â„•;
		(qm2,qm1)=(qm1,aÂ·qm1+qm2);
		r~=[qm1];
		x-=a;
	}
	return r;
}

def powm(a:!â„•,b:!â„•,N:!â„•){
	r:=1;
	x:=a;
	while bâ‰ 0{
		if b&1{
			r=r*x%N;
		}
		x=x^2%N;
		b div=2;
	}
	return r;
}

// compute d=gcd(a,b) and k with aÂ·k â‰¡ d (mod b)
def egcd(a:!â„¤,b:!â„¤){
	(x,y,u,v):=(a,b,1,0):!â„¤^4;
	while yâ‰ 0{
		(x,y,u,v)=(y,x%y,v,u-(x div y)Â·v);
	}
	return (x,u);
}
def gcdn(a:!â„•,b:!â„•):!â„•â‡’gcd(a,b) coerce !â„•;
def gcd(a:!â„¤,b:!â„¤):!â„¤â‡’egcd(a,b)[0];
