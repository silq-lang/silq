// skipped

// ======================= Utilities =======================

// e^{-i Î¸ ZâŠ—Z} via odd-parity phase (up to a global phase).
def rzz[theta:!â„](const qi:ğ”¹, const qj:ğ”¹){
	if qi â‰  qj { phase(2Â·theta); }   // odd parity gets +2Î¸ relative phase
}

// Compute (weighted) cut value for classical bitstring 'bits'.
def cut_value[n:!â„•, m:!â„•](edges:(!â„•Ã—!â„•)^m, w:!â„^m, bits:!ğ”¹^n):!â„{
	total := 0;
	for k in 0..m {
		(u, v) := edges[k];
		if bits[u] â‰  bits[v] { total += w[k]; }
	}
	return total;
}

// Clamp a real into [lo, hi].
def clamp(x:!â„, lo:!â„, hi:!â„):!â„{
	if x < lo { return lo; }
	if x > hi { return hi; }
	return x;
}

// Clamp all angles in a vector into [0, Ï€].
def clamp_angles[p:!â„•](angles:!â„^p):!â„^p{
	// for i in 0..p { angles[i] = clamp(angles[i], 0.0, Ï€); } // TODO
	for i in 0..p { angles[i] := clamp(angles[i], 0.0, Ï€); }
	return angles;
}

// ======================= p-layer QAOA =======================

// One measured sample after applying p layers with betas[0..p), gammas[0..p)
def qaoa_sample_once_p[n:!â„•, m:!â„•, p:!â„•](
	edges:(!â„•Ã—!â„•)^m,
	w:!â„^m,
	betas:!â„^p,
	gammas:!â„^p
):!ğ”¹^n{
	// 1) Init |+âŸ©^n
	q := vector(n, 0);
	for i in 0..n { q[i] := H(q[i]); }

	// 2) p layers: cost then mixer
	for â„“ in 0..p {
		// Cost U_C(Î³_â„“)
		for k in 0..m {
			(u, v) := edges[k];
			Î¸ := gammas[â„“]Â·w[k];
			rzz[Î¸](q[u], q[v]);
		}
		// Mixer U_B(Î²_â„“) = âŠ— RX(2Î²_â„“)
		for i in 0..n { q[i] := rotX(2Â·betas[â„“], q[i]); }
	}

	// 3) Measure one bitstring
	return measure(q);
}

// Monte-Carlo estimate of E[C] for given angles
def qaoa_expectation_p[n:!â„•, m:!â„•, p:!â„•](
	edges:(!â„•Ã—!â„•)^m,
	w:!â„^m,
	betas:!â„^p,
	gammas:!â„^p,
	shots:!â„•
):!â„{
	acc := 0.0;
	for s in [0..shots) {
		bits := qaoa_sample_once_p[n,m,p](edges, w, betas, gammas);
		acc += cut_value[n,m](edges, w, bits);
	}
	return acc/shots;
}

// ======================= Trust-region optimizer (n-D; n = 2p) =======================
// Unconstrained maximization over (betas, gammas), both âˆˆ [0, Ï€]^p.
// Two-sided finite-difference gradient; trust-region ascent with adaptive radius.
def optimize_trust_p[p:!â„•](
	// objective to *maximize*
	f:!â„^p x !â„^p !->!â„,
	betas0:!â„^p,
	gammas0:!â„^p,
	rho0:!â„, rho_min:!â„,
	max_iter:!â„•
):!â„^p x !â„^p x !â„{
	Î² := clamp_angles[p](betas0);
	Î³ := clamp_angles[p](gammas0);
	Ï := rho0;
	f_best := f(Î², Î³);
	Î²_best := Î²; Î³_best := Î³;

	for it in 0..max_iter {
		Î´ := Ï;

		// Finite-difference gradient wrt Î²
		gÎ² := vector(p, 0.0);
		for i in 0..p {
			Î²p := Î²; Î²p[i] = clamp(Î²[i] + Î´, 0, Ï€);
			Î²m := Î²; Î²m[i] = clamp(Î²[i] - Î´, 0, Ï€);
			gÎ²[i] = (f(Î²p, Î³) - f(Î²m, Î³)) / (2Â·Î´);
		}

		// Finite-difference gradient wrt Î³
		gÎ³ := vector(p, 0.0);
		for i in 0..p {
			Î³p := Î³; Î³p[i] = clamp(Î³[i] + Î´, 0.0, Ï€);
			Î³m := Î³; Î³m[i] = clamp(Î³[i] - Î´, 0.0, Ï€);
			gÎ³[i] = (f(Î², Î³p) - f(Î², Î³m)) / (2.0Â·Î´);
		}

		// Gradient norm
		gn := 0.0;
		for i in 0..p { gn += gÎ²[i]Â·gÎ²[i] + gÎ³[i]Â·gÎ³[i]; }
		gn = sqrt(max(gn, 1e-16));

		if gn < 1e-6 {
			Ï = Ï/2;
		} else {
			// Ascent step: (Î²,Î³) â† (Î²,Î³) + Ï Â· g / ||g||
			Î²_try := Î²; Î³_try := Î³;
			for i in 0..p {
				Î²_try[i] = clamp(Î²[i] + (ÏÂ·gÎ²[i] / gn), 0, Ï€);
				Î³_try[i] = clamp(Î³[i] + (ÏÂ·gÎ³[i] / gn), 0, Ï€);
			}
			f_try := f(Î²_try, Î³_try);

			if f_try > f_best {
				Î² = Î²_try; Î³ = Î³_try; f_best = f_try;
				Î²_best = Î²; Î³_best = Î³;
				Ï = min(ÏÂ·1.25, 0.5);
			} else {
				Ï = ÏÂ·0.5;
			}
		}

		// if (Ï < rho_min) { break; } // TODO
		if Ï < rho_min { return (Î²_best, Î³_best, f_best); }
	}

	return (Î²_best, Î³_best, f_best);
}

def main(){
	// ======================= Example: C4, p=2 =======================
	// Graph: 0â€”1â€”2â€”3â€”0 (unweighted; optimum cut = 4)
	n := 4:!â„•;
	m := 4:!â„•;
	edges :(!â„•Ã—!â„•)^m := [(0,1), (1,2), (2,3), (3,0)] coerce _^m;
	w     :!â„^m      := [1.0, 1.0, 1.0, 1.0] coerce _^m;

	p := 2:!â„•;
	
	// Heuristic init that often works: Î² increasing, Î³ decreasing
	betas0 :!â„^p  := [0.3, 0.5] coerce _^p;
	gammas0:!â„^p  := [0.8, 0.6] coerce _^p;
	
	/+// ---------- Example: Petersen graph (n=10, m=15) ----------
	n:=10;
	m:=15;
	// Edges: outer 5-cycle, spokes, inner pentagram
	edges :(!â„•Ã—!â„•)^m := [
		// outer cycle
		(0,1), (1,2), (2,3), (3,4), (4,0),
		// spokes
		(0,5), (1,6), (2,7), (3,8), (4,9),
		// inner pentagram: 5-7-9-6-8-5
		(5,7), (7,9), (9,6), (6,8), (8,5)
	] coerce _^m;

	// Unweighted MaxCut
	w :!â„^m := [1.0, 1.0, 1.0, 1.0, 1.0,
				1.0, 1.0, 1.0, 1.0, 1.0,
				1.0, 1.0, 1.0, 1.0, 1.0] coerce _^m;

	p := 3:!â„•;

	// Heuristic init: Î² ramp up, Î³ ramp down (often transfers well)
	betas0  :!â„^p := [0.25, 0.45, 0.60] coerce _^p;
	gammas0 :!â„^p := [0.90, 0.70, 0.50] coerce _^p;+/
	
	shots_eval := 12:!â„•;
	def obj(Î²:!â„^p, Î³:!â„^p):!â„{
		return qaoa_expectation_p[n,m,p](edges, w, Î², Î³, shots_eval);
	}

	rho0 := 0.2; rho_min := 1e-3; max_iter := 10:!â„•;
	(betas, gammas, f) := optimize_trust_p[p](obj, betas0, gammas0, rho0, rho_min, max_iter);

	/+print("Optimized betas: ");+/  print(betas);
	/+print("Optimized gammas: ");+/ print(gammas);
	/+print("Estimated E[C]: ");+/   print(f);

	// Final sampling at optimized angles; keep best sample
	final_shots := 3:!â„•;
	best_bits :!ğ”¹^n := vector(n, false);
	best_val := -1e9;
	for s in [0..final_shots) {
		bits := qaoa_sample_once_p[n,m,p](edges, w, betas, gammas);
		val  := cut_value[n,m](edges, w, bits);
		if val > best_val { best_val = val; best_bits = bits; }
	}

	/+print("Best sample bits: ");+/ print(best_bits);
	/+print("Best sample cut value: ");+/ print(best_val);

	// -------- Optional: 1-flip local polish (on classical side) --------
	improved := true;
	bits2 := best_bits;
	val2 := best_val;
	while improved {
		improved = false;
		for i in 0..n {
			bits_try := bits2;
			bits_try[i] = !bits_try[i];   // flip classical bit
			val_try := cut_value[n,m](edges, w, bits_try);
			if val_try > val2 {
				bits2 = bits_try;
				val2 = val_try;
				improved = true;
			}
		}
	}
	/+print("Polished bitstring: ");+/ print(bits2);
	/+print("Polished cut value: ");+/ print(val2);
}
