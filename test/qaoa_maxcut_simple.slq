// args: --run

// ---------- Utilities ----------

// e^{-i theta ZâŠ—Z} via CNOTâ€“RZâ€“CNOT (up to a global phase).
def rzz[theta:!â„](const qi:ð”¹, const qj:ð”¹){
	if qi â‰  qj { phase(2Â·theta); }
}

// Compute (weighted) cut value for classical bitstring 'bits'.
def cut_value[n:!â„•,m:!â„•](edges:(!â„•Ã—!â„•)^m, w:!â„^m, bits:!ð”¹^n):!â„{
	total := 0;
	for k in 0..m {
		(u, v) := edges[k];
		if (bits[u] != bits[v]) {
			total += w[k];
		}
	}
	return total;
}

// ---------- One QAOA layer (p=1) ----------
// Applies U_C(gamma) Â· U_B(beta) to the |+>^n state and returns one measured sample.
def qaoa_sample_once[m:!â„•](
	n:!â„•,
	edges:(!â„•Ã—!â„•)^m,
	w:!â„^m,
	beta:!â„,
	gamma:!â„
):!ð”¹^n{
	// 1) Init |+âŸ©^n
	q := vector(n, 0);
	for i in 0..n { q[i] := H(q[i]); }

	// 2) Cost unitary U_C(gamma) = Î _{(u,v)} e^{-i gamma * w_uv Z_u Z_v}
	for k in 0..m {
		(u, v) := edges[k];
		Î¸ := gammaÂ·w[k];
		rzz[Î¸](q[u], q[v]);
	}

	// 3) Mixer U_B(beta) = âŠ—_i RX(2 beta)
	for i in 0..n { q[i] := rotX(2*beta, q[i]); }
	
	// 4) Sample one bitstring
	return measure(q);   // classical vector !^n
}

// ---------- Driver: run many shots and keep the best ----------
def run_qaoa_maxcut[m:!â„•](
	n:!â„•,
	edges:(!â„•Ã—!â„•)^m,
	w:!â„^m,
	beta:!â„,
	gamma:!â„,
	shots:!â„•
): !ð”¹^n x !â„{
	best_bits := vector(n, false);
	best_val  := -1e9;
	for s in [0..shots) {
		print(s,best_val);
		bits := qaoa_sample_once(n, edges, w, beta, gamma);
		val  := cut_value(edges, w, bits);
		if val > best_val {
			best_val  = val;
			best_bits = bits;
		}
	}
	return (best_bits, best_val);
}

// ---------- Example: 4-node cycle C4 ----------
def main(){
	// Graph: 0â€”1â€”2â€”3â€”0  (unweighted MaxCut optimum = 4)
	n := 4:!â„•;
	edges := [(0,1), (1,2), (2,3), (3,0)];
	w := [1.0, 1.0, 1.0, 1.0];
	
	// Hand-picked (Î²,Î³) that work well on C4 for p=1.
	beta := 0.5:!â„;
	gamma := 0.7:!â„;
	
	shots := 10:!â„•;
	(best_bits, best_val) := run_qaoa_maxcut(n, edges, w, beta, gamma, shots);

	//print("Best bitstring: ");
	print(best_bits);
	//print("Cut value: ");
	print(best_val);

	// (Optional) simple 1-flip local polish to ensure local optimality
	// Uncomment if you want a quick classical refinement.

	improved := true;
	bits2 := best_bits;
	val2 := best_val;
	while improved {
		improved = false;
		for i in 0..n {
			// try flipping bit i
			bits_try := bits2;
			bits_try[i] = !bits_try[i]; // flip classical bit
			val_try := cut_value(edges, w, bits_try);
			if val_try > val2 {
				bits2 = bits_try;
				val2 = val_try;
				improved = true;
			}
		}
	}
	/+print("Polished bitstring: ");+/ print(bits2);
	/+print("Polished cut value: ");+/ print(val2);
}
