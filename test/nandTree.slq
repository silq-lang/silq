// simplified algorithm for evaluating balanced binary nand trees
// Figure 2 in paper: http://www.ucw.cz/~robert/papers/andor-siamjc.pdf

// (down,left,right):=(0,1,2):!uint[2]^3; // TODO
down:=0:!uint[2];
left:=1:!uint[2];
right:=2:!uint[2];

def logâ‚‚(k:!â„•)qfree:!â„• â‡’ if k=1 then 0 else 1+logâ‚‚((k+1) div 2);

def makeUniform(k:!â„•)mfree:uint[logâ‚‚(k)]{
	return wToUniform(zeroToW(vector(k,0:ğ”¹))); // inefficient
	/*while true{ // not mfree
		x:=0:uint[logâ‚‚(k)];
		for i in 0..logâ‚‚(k){ x[i]:=H(x[i]); }
		if measure(x<k){ return x; }
		measure(x);
	}*/
}

def phaseQ[n:!â„•](const Ï†:uint[n])mfree{
	for i in [0..n){ if Ï†[i]{ phase(2Â·Ï€Â·2^i/2^n); } }
}

def uniformToW[k:!â„•](x:uint[logâ‚‚(k)])qfree:ğ”¹^k{
	y:=vector(k,0:ğ”¹);
	for i in 0..k{ y[i]=x=i; }
	def getx(const y:ğ”¹^k,const i:!â„•)qfree:uint[logâ‚‚(k)]{
		if i==0{ return 0 as uint[logâ‚‚(k)]; }
		if y[i]{ return i as uint[logâ‚‚(k)]; }
		return getx(y,i sub 1);
	}
	forget(x=getx(y,k sub 1));
	return y;
}

// def wToUniform[k:!â„•](y:ğ”¹^k)mfreeâ‡’reverse(uniformToW)(y); // TODO

def wToUniform[k:!â„•](y:ğ”¹^k)mfree{
	def getx(const y:ğ”¹^k,const i:!â„•)qfree:uint[logâ‚‚(k)]{
		if i==0{ return 0 as uint[logâ‚‚(k)]; }
		if y[i]{ return i as uint[logâ‚‚(k)]; }
		return getx(y,i sub 1);
	}
	x:=getx(y,k sub 1);
	forget(y=uniformToW(dup(x)));
	return x;
}

def zeroToW[n:!â„•](x:ğ”¹^n)mfree:ğ”¹^n{
	if n==1{ x[0]:=X(x[0]); }
	else if n>1{
		(head,)~tail:=x;
		Î¸:=2Â·asin(1/sqrt(n));
		head:=rotY(Î¸,head);
		if !head { tail := zeroToW(tail); }
		x:=(head,)~tail;
	}
	return x;
}
def wToZero[n:!â„•](x:ğ”¹^n)mfree:ğ”¹^nâ‡’reverse(zeroToW)(x);

def zeroToUniform[n:!â„•](x:ğ”¹^n)mfree:uint[logâ‚‚(n)]â‡’wToUniform(zeroToW(x));
// def uniformToZero[n:!â„•](x:uint[logâ‚‚(n)])mfree:ğ”¹^nâ‡’reverse(zeroToUniform)(x); // TODO
def uniformToZero[n:!â„•](x:uint[logâ‚‚(n)])mfree:ğ”¹^nâ‡’wToZero(uniformToW(x));

def reflâ‚(c:uint[2])mfree:uint[2]{ // apply reflection 2|uâŸ©âŸ¨u|-1, u=1/âˆš3(|0âŸ©+|1âŸ©+|2âŸ©)
	c:=uniformToZero[3](c as ğ”¹^2 coerce ğ”¹^logâ‚‚(3) as uint[logâ‚‚(3)]) as uint[3];
	if câ‰ 0{ phase(Ï€); }
	return zeroToUniform(c as ğ”¹^3) as ğ”¹^logâ‚‚(3) coerce ğ”¹^2 as uint[2];
}

def reflâ‚‚[N:!â„•](c:uint[2])mfree{ // apply reflection 2|u'âŸ©âŸ¨u'|-1, u'=1/N^Â¼|0âŸ©+âˆš(1-1/âˆšN)|1âŸ©
	(x,y):=c as ğ”¹^2;
	if !y{
		Î¸:=2Â·asin(sqrt(1-1/sqrt(N)));
		x:=rotY(Î¸,Z(rotY(-Î¸,x)));
	}else{
		phase(Ï€);
	}
	return (x,y) as uint[2];
}

def QFT[n:!â„•](Ïˆ: uint[n])mfree: uint[n]{
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	for k in [0..n){
		Ïˆ[k] := H(Ïˆ[k]);
		for l in [k+1..n){
			if Ïˆ[l] && Ïˆ[k]{
				phase(2Â·Ï€ Â· 2^(k-l-1));
			}
		}
	}
	return Ïˆ;
}

def evalNand[V:qtype](
	N:!â„•,
	râ‚‚:V,
	isRâ‚:V!â†’lifted ğ”¹,
    read:V!â†’lifted ğ”¹,
	isLeaf: V!â†’lifted ğ”¹,
	isInternal: V!â†’lifted ğ”¹,
	walk: VÃ—uint[2]!â†’mfree VÃ—uint[2],
){
	Ï„:=320Â·floor(sqrt(N)) coerce !â„•;
	n:=logâ‚‚(N);
	Ï„=2^n; // TODO: QFT on â„¤_N where N is not a power of two
	//t:=makeUniform(Ï„);
	t:=0:uint[n];
	for i in 0..n{ t[i]:=H(t[i]); }
	phaseQ((t[0],t[1]) as uint[2]):=(); // TODO: slicing for integers?
	v:=râ‚‚;
	c:uint[2]:=left;
	for i in 0..Ï„{
		if i<t{
			// diffusion step
			if isLeaf(v){
				if read(v){ phase(Ï€); }
			}else if isInternal(v){
				c:=reflâ‚(c);
			}else if isRâ‚(v){
				c:=reflâ‚‚[N](c);
			}
			// walk step
			(v,c):=walk(v,c);
		}
	}
	t:=reverse(QFT)(t);
	measure(v,c);
	t:=measure(t);
	return t=0||t=Ï„ div 2;
}

def main(){
	//counter:=makeUniform(3);
	//phaseQ((counter[0],counter[1]) as uint[2]):=(); // TODO: slicing for integers?
	//return counter;
	//return reverse(zeroToW)(uniformToW(counter));
	//return uniformToW(counter);
	//counter:=1:uint[2];
	counter:=0:uint[2];
	Î¸:=2Â·asin(sqrt(1-1/sqrt(25)));
	counter[0]:=rotY(Î¸,counter[0]);
	return reflâ‚‚[25](counter);
}
