/+
Renatoâ€™s communication game
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
n players, who can communicate only two classical bits on a chain: Aâ‚€ â†’ Aâ‚ -> Aâ‚‚ â‹¯ â†’ Aâ‚™â‚‹â‚ -> Referee
Each player Aáµ¢ receives as input a real number Î±áµ¢. Promise: âˆ‘áµ¢Î±áµ¢ is a natural number k.
The player Aâ‚™â‚‹â‚ should tell the referee whether k is even or odd.
The players are allowed to share a strategy (in particular, to share a large entangled state)
before the game starts (i.e. before they know the Î±s).
+/

/+
Solution idea
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
The players can propagate a single qubit q with quantum teleportation.
The first player prepares the qubit in the |+âŸ© state and the i-th player changes
the phase of |1âŸ© by Ï€Â·Î±áµ¢. In the end, q is in the state 1/âˆš2(|0âŸ©+e^(iÏ€k)|1âŸ©), and
therefore H(q) yields the parity of k, which player n-1 sends to the referee.
+/

def makeTeleporter(){ // quantum teleportation with send and receive ends
	sharedâ‚€:=H(0:ğ”¹);
	sharedâ‚:=dup(sharedâ‚€);
	def send(message:ğ”¹){
		if message { sharedâ‚€:=X(sharedâ‚€); }
		return measure(sharedâ‚€,H(message));
	}
	def receive(bits:!ğ”¹^2){
		if bits[0]{ sharedâ‚:=X(sharedâ‚); }
		if bits[1]{ sharedâ‚:=Z(sharedâ‚); }
		return sharedâ‚;
	}
	return (send,receive); // send and receive are called at most once (checked by type system)
}

def fill[Ï„](n:!â„•,f:ğŸ™!â†’Ï„):Ï„^nâ‡’if n==0 then ()coerce Ï„^n else fill(n sub 1,f)~(f(),);

def prepareState(n:!â„•){ // prepares n pieces of quantum data, distributed to players
	Ï†:=fill(n,makeTeleporter); // create a quantum teleportation channel for each player
	for i in (n-1..-1..0]{ // distribute receive ends to make ring topology
		(Ï†[i][1],Ï†[i+1][1]):=(Ï†[i+1][1],Ï†[i][1]);
	}
	return Ï†;
}
def start(send:ğ”¹â†’!ğ”¹^2,Î±â‚€:!â„){ // strategy for player 0
	q:=H(0:ğ”¹);
	if q { phase(Ï€Â·Î±â‚€); }
	return send(q);
}
def forward(send:ğ”¹â†’!ğ”¹^2,receive:!ğ”¹^2â†’ğ”¹,bits:!ğ”¹^2,Î±áµ¢:!â„){ // strategy for players 1, â€¦, n-2
	q:=receive(bits);
	if q { phase(Ï€Â·Î±áµ¢); }
	return send(q);
}
def end(receive:!ğ”¹^2â†’ğ”¹,bits:!ğ”¹^2,Î±â‚™â‚‹â‚:!â„){ // strategy for player n-1.
	q:=receive(bits);
	if q { phase(Ï€Â·Î±â‚™â‚‹â‚); }
	return measure(H(q));
}
def solve[n:!â„•](Î±:!â„^n){ // simulates one game
	Ï†:=prepareState(n):((ğ”¹â†’!ğ”¹^2)Ã—(!ğ”¹^2â†’ğ”¹))[]; // create ring topology in variable-length array
	[(send,receive)]~Ï†:=Ï†; // pop off send and receive ends for player 0
	measure(receive); // player 0's receive end is unused, trace it out
	bits:=start(send,Î±[0]);
	for i in [1..n-1){
		[(send,receive)]~Ï†:=Ï†;
		bits=forward(send,receive,bits,Î±[i]);
	}
	[(send,receive)]:=Ï†;
	measure(send); // player n-1's send end is unused, trace it out
	return end(receive,bits,Î±[n-1]);
}

def main(){
	Î±â‚€:=(1/2,1/3+sqrt(3),1/3,1/2-sqrt(3),1/3); // kâ‚€=2
	Î±â‚:=(1/2,3-sqrt(2),1/3,1/6,1+sqrt(2));     // kâ‚=5
	return (solve(Î±â‚€),solve(Î±â‚));
}
