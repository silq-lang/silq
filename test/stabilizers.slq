// args: --run

i:=0,x:=1,y:=2,z:=3;
P:=!â„•;

def applyP(p:P)(x:ğ”¹)â‡’[I,X,Y,Z][p](x);
def measP(p:P)(x:ğ”¹){
	a:=H(0);
	if a { x:=applyP(p)(x); }
	return (measure(H(a)),x);
}
def applyPs[n:!â„•](ps:P^n)(xs:ğ”¹^n){
	for i in 0..n{
		xs[i]:=applyP(ps[i])(xs[i]);
	}
	return xs;
}
def measPs[n:!â„•](ps:P^n)(xs:ğ”¹^n){
	a:=H(0);
	if a { xs:=applyPs(ps)(xs); }
	return (measure(H(a)),xs);
}

ebit2:=[[z,z],
	   [x,x]];

ghz3:=[[z,z,i],
	  [i,z,z],
	  [x,x,x]];

rep3:=[[z,z,i],
	   [i,z,z]];

five:=[[x,z,z,x,i],
	   [i,x,z,z,x],
	   [x,i,x,z,z],
	   [z,x,i,x,z]];

steane7:=[[z,z,z,z,i,i,i],
		  [z,z,i,i,z,z,i],
		  [z,i,z,i,z,i,z],
		  [x,x,x,x,i,i,i],
		  [x,x,i,i,x,x,i],
		  [x,i,x,i,x,i,x]];

shor9:=[[z,z,i,i,i,i,i,i,i],
		[i,z,z,i,i,i,i,i,i],
		[i,i,i,z,z,i,i,i,i],
		[i,i,i,i,z,z,i,i,i],
		[i,i,i,i,i,i,z,z,i],
		[i,i,i,i,i,i,i,z,z],
		[x,x,x,x,x,x,i,i,i],
		[i,i,i,x,x,x,x,x,x]];

def syndrome[n:!â„•,r:!â„•](stab:(P^n)^r)(xs:ğ”¹^n){
	s:=();
	for i in 0..r{
		(p,xs):=measPs(stab[i])(xs);
		s~=[p];
	}
	return (s coerce !ğ”¹^r,xs);
}

def bruteforce_fix[n:!â„•,r:!â„•](stab:(P^n)^r)(s:!ğ”¹^r,xs:ğ”¹^n){
	for mask in 0..2^(2Â·n){
		mask:=mask as !uint[2Â·n];
		cs:=vector(r,0);
		for i in 0..r{
			for j in 0..2Â·n{
				if mask[j]{
					if stab[i][j%n]=[z,x][j div n]{
						cs[i]âŠ•=1;
					}
				}
			}
		}
		if cs=s{
			for j in 0..2Â·n{
				if mask[j]{
					xs[j%n]:=[X,Z][j div n](xs[j%n]);
				}
			}
			return xs;
		}
	}
	assert(0);
}

def split_stab_xz[n:!â„•,r:!â„•](stab:(P^n)^r){
	(xss,zss):=([],[]);
	for i in 0..r{
		(xs,zs):=([],[]);
		for j in 0..n{
			assert([1,1,0,1][stab[i][j]]);
			xs~=[stab[i][j]=x];
			zs~=[stab[i][j]=z];
		}
		xss~=[xs coerce _^n];
		zss~=[zs coerce _^n];
	}
	return (xss coerce _^r, zss coerce _^r);
}

def popcnt[n:!â„•](x:!uint[n])lifted{
	r:=0;
	for i in 0..n{ r+=x[i]; }
	return r;
}

def encodings[n:!â„•,r:!â„•](stab:(P^n)^r){
	(xs,zs):=split_stab_xz(stab) as (!uint[n]^r)^2;
	sign:=vector(2^n,2);
	queue:=vector(2^n,0:!uint[n]);
	(s,e):=(0,0);
	result:=[];
	for i in 0..2^n{
		if sign[i]=2{
			ok:=1;
			sign[i]=1;
			queue[e]=i as !uint[n];
			e+=1;
			component:=[];
			while s<e{
				cur:=queue[s];
				cs:=sign[cur];
				s+=1;
				component~=[(cs,cur as !uint[n] as !ğ”¹^n)];
				for j in 0..r{
					ns:=if popcnt(zs[j]&cur)&1 then -cs else cs;
					next:=xs[j]âŠ•cur;
					if sign[next]=2{
						sign[next]=ns;
						queue[e]=next;
						e+=1;
					}else{
						ok&=ns=sign[next];
					}
				}
			}
			if ok{
				result~=[component];
			}
		}
	}
	return result;
}

import uniformSuperposition;
def bruteforce_encode[n:!â„•](const xs:(!â„¤Ã—!ğ”¹^n)[]){
	size:=xs.length;
	index:=uniformSuperposition(size);
	result:=vector(n,0);
	for i in 0..size{
		if i=index{
			if xs[i][0]=-1{ phase(Ï€); }
			result=xs[i][1];
		}
	}
	forget(index=(){
		index:=0:uint[ceil(logâ‚‚(size)) coerce !â„•];
		for i in 0..size{
			if result=xs[i][1]{
				index=i as uint[ceil(logâ‚‚(size)) coerce !â„•];
			}
		}
		return index;
	}());
	return result;
}

def main(){
	stab:=five;
	encs:=encodings(stab);
	for i in 0..encs.length{
		ks:=bruteforce_encode(encs[i]);
		(s,ks):=syndrome(stab)(ks);
		assert(s=vector(s.length,0));
		measure(s,ks);
	}
	(s,xs):=syndrome(stab)(vector(stab[0].length,0));
	print(s);
	xs:=bruteforce_fix(stab)(s,xs);
	(s,xs):=syndrome(stab)(xs);
	print(s);
	return xs;
}
