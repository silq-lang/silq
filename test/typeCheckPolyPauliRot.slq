def mkvec(n:!â„•)[a](f:!â„•!â†’qfree a)qfree:!a^n â‡’ if n=0 then () coerce !a^n else mkvec(n sub 1)(f)~(f(n sub 1),);

def nextCoeffs[n:!â„•](mcoeffs:!â„•^(2^n))qfree â‡’ mkvec(2^n)((i:!â„•)qfree{
	mask:=i as !uint[n];
	def sum(j:!â„•)qfree:!â„• â‡’ if j<n then (if mask[j] then 2^jÂ·(mcoeffs[i]+mcoeffs[iâŠ•2^j]) else 0)+sum(j+1) else 0;
	return sum(0);
});

def for_(i:!â„•,n:!â„•)[a,b](f: !â„•Ã—aÃ—b!â†’lifted aÃ—b)(x:a,y:b)lifted:aÃ—bâ‡’if i<n then for_(i+1,n)(f)(f(i,x,y)) else (x,y);

def polyPauliRot[a:qtype](rot: !â„Ã—a!â†’mfree a)[d:!â„•](coeffs:!â„^(d+1))[n:!â„•](const state:ð”¹^n,target:a)mfree{
	mcoeffs:=vector(2^n,0);
	mcoeffs[0]=1;
	rotation_coeffs:=vector(2^n,0);
	(rotation_coeffs,mcoeffs)
	=for_(0,d+1)((i:!â„•,rotation_coeffs:!â„^(2^n),mcoeffs:!â„•^(2^n))qfree{
		nrotation_coeffs:=mkvec(2^n)((j:!â„•)qfreeâ‡’rotation_coeffs[j]+coeffs[i]*mcoeffs[j]);
		if i<d { ncoeffs:=nextCoeffs(mcoeffs); }
		else{ ncoeffs:=mcoeffs; }
		return (nrotation_coeffs,ncoeffs);
	})(rotation_coeffs,mcoeffs);
	//print(rotation_coeffs);
	//__show(__query("type",k));
	__show(__query("type",rotation_coeffs));
	for i in 0..2^n{
		if rotation_coeffs[i]!=0{
			mask:=i as !uint[n];
			def rec(const state:ð”¹^n,const mask:!uint[n],j:!â„•,target:a)mfree:aâ‡’
				if nâ‰¤j then rot(rotation_coeffs[i],target)
				else if mask[j] then if state[j] then rec(state,mask,j+1,target) else target
				else rec(state,mask,j+1,target);
			target:=rec(state,mask,0,target);
		}
	}
	return target;
}

def main(){
	return polyPauliRot(rotY)[3](1,2,3,4)(3 as uint[5] as ð”¹^5,1:ð”¹);
}
