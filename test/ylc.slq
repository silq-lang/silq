// Yoderâ€“Lowâ€“Chuang

// TODO: add built-ins
// def acot(x: !â„) : !â„ â‡’ atan2(1.0, x);
def acot(x: !â„)â‡’Ï€/2 - atan(x);
def cosh(x:!â„)â‡’(exp(x)+exp(-x))/2;
def acosh(x:!â„)â‡’log(x+sqrt((x-1)Â·(x+1)));

// Hadamards on all n qubits
def H_n[n:!â„•](xs: uint[n]) {
	for i in 0..n { xs[i] := H(xs[i]); }
	return xs;
}

// Generalized reflection about |s> = H_n|0â€¦0âŸ© with phase Î¸:
// S_s(Î¸) = I - (1 - e^{iÎ¸})|sâŸ©âŸ¨s| = H_n Â· (phase Î¸ on |0â€¦0âŸ©) Â· H_n
def S_s[n:!â„•](cand: uint[n], Î¸: !â„) {
	with cand := H_n(cand) do
		if cand == 0 { phase(Î¸); }
	return cand;
}

// Generalized reflection about the marked subspace with phase Î¸:
// S_t(Î¸) = I - (1 - e^{iÎ¸}) Î _Ï‰
def S_t[n:!â„•](cand: uint[n], const f: const uint[n] â†’ lifted ð”¹, Î¸: !â„) {
	if f(cand) { phase(Î¸); }
	return cand;
}

// build Î±,Î² from L,Î´
def ylc_Î±Î²(L: !â„•, Î´: !â„) : !â„^(L div 2) x !â„^(L div 2) x !â„ {
	assert(L % 2 == 1);
	â„“ := L div 2;

	Î³inv := cosh((1/L)*acosh(1/Î´));
	Î³    := 1/Î³inv;
	Ï    := sqrt(max(0,1-Î³^2));

	Î² := vector(â„“, 0);
	for j in 0..â„“ {
		t := tan(Ï€Â·(j+1)/L);
		Î²[j] = 2Â·acot(tÂ·max(Ï,1e-16) );  // Î²_j
	}
	Î± := vector(â„“, 0.0);
	for j in 0..â„“ {
		Î±[j] = Î²[(â„“ sub 1)-j];           // Î±_j = Î²_{â„“-j}
	}
	center := (if â„“ % 2 == 0 then 1 else -1)Â·Ï€/2;
	return (Î± coerce !â„^(L div 2), Î² coerce !â„^(L div 2), center);
}

// fixed-point AA
def ylc_fixed_point[n:!â„•](const f: const uint[n] â†’ lifted ð”¹, L: !â„•, Î´: !â„) {
	assert(L % 2 == 1);
	cand := H_n(0:uint[n]);
	(Î±, Î², center) := ylc_Î±Î²(L, Î´);

	for j in 0..L div 2 {
		cand := S_s(cand, Î±[j]);
		cand := S_t(cand, f, Î²[j]);
	}
	cand := S_s(cand, center);
	return cand;
}

// Choose an odd L >= 3 for YLC given exact M, N and target Î´ in (0,1).
def ylc_choose_L(M: !â„•, N: !â„•, Î´: !â„) : !â„• {
	assert(N > 0 && M > 0 && M <= N);
	assert(Î´ > 0 && Î´ < 1);

	Î»_:= M/N;
	L := ceil(acosh(1/Î´)/sqrt(Î»_)) coerce !â„•;
	if L<3 { L=3; }
	if L%2=0 { L+=1; }
	return L;
}

def ylc_staged_heralded[n:!â„•](const f: const uint[n] â†’ lifted ð”¹) {
	j := 0;
	L := 3;

	while true{
		j += 1;
		if j > 1 {
			if L=3 { L=5; }
			else   { L=2*L sub 1; }
		}
		Î´ := 1/(j+5);
		cand := ylc_fixed_point(f, L, Î´);
		if measure(f(cand)) { return cand; }
		measure(cand);
	}
}

n:=6;
def main(){
	Î´:=0.0005;
	L:=ylc_choose_L(2,2^n,Î´);
	return ylc_fixed_point((x:uint[n])liftedâ‡’x=42|x=17,L,Î´);
}

// def main() â‡’ ylc_staged_heralded((x:uint[6])liftedâ‡’x=42|x=17);
