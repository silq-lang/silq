
def fromAngle[n:!â„•](Ï†:!â„)liftedâ‡’round(Ï†/(2Â·Ï€)Â·2^n) as !int[n];
def toAngle[n:!â„•](Ï†:!int[n])liftedâ‡’2Â·Ï€Â·(Ï† as !â„¤)/2^n;

def fromRange[a:!â„,b:!â„][n:!â„•](x:!â„)liftedâ‡’round((x-a)/(b-a)Â·(2^n-1)) as !uint[n];
def toRange[a:!â„,b:!â„][n:!â„•](x:!uint[n])liftedâ‡’a+(x as !â„¤)/(2^n-1)Â·(b-a);

/// computes fromRange[-1,1][n](sin(toAngle[m](x)))
def sinQ[m:!â„•,n:!â„•]lifted(x:int[m])lifted:uint[n]{
	def impl(n:!N, x: int[m]) @[extern="primitive.qfixed.sin"] qfree: uint[n];
	return impl(n, x);
}

/// computes fromAngle[n](asin(toRange[-1,1][m](x)))
def asinQ[m:!â„•,n:!â„•](x:uint[m])lifted:int[n]{
	def impl(n:!N, x: uint[m]) @[extern="primitive.qfixed.asin"] qfree: int[n];
	return impl(n, x);
}

/// computes fromRange[-1,1][n](cos(toAngle[m](x)))
def cosQ[m:!â„•,n:!â„•]lifted(x:int[m])lifted:uint[n]{
	def impl(n:!N, x: int[m]) @[extern="primitive.qfixed.cos"] qfree: uint[n];
	return impl(n, x);
}

/// computes fromAngle[n](acos(toRange[-1,1][m](x)))
def acosQ[m:!â„•,n:!â„•](x:uint[m])lifted:int[n]{
	def impl(n:!N, x: uint[m]) @[extern="primitive.qfixed.acos"] qfree: int[n];
	return impl(n, x);
}

/// computes fromRange[0,1][n](c/toRange[0,1][m](x))
def invQ[m:!â„•,n:!â„•,c:!â„](x:uint[m])lifted:uint[n]{
	def impl(n:!N, x: uint[m], c: !R) @[extern="primitive.qfixed.inv"] qfree: uint[n];
	return impl(n, x, c);
}

def phaseQ[n:!â„•](const Ï†:int[n])mfree{
	for i in [0..n){ if Ï†[i]{ phase(2Â·Ï€Â·2^i/2^n); } }
}
def rotXQ[n:!â„•](const Ï†:int[n],x:ğ”¹)mfree{
	for i in [0..n){ if Ï†[i]{ x:=rotX(2Â·Ï€Â·2^i/2^n,x); } }
	return x;
}
def rotYQ[n:!â„•](const Ï†:int[n],x:ğ”¹)mfree{
	for i in [0..n){ if Ï†[i]{ x:=rotY(2Â·Ï€Â·2^i/2^n,x); } }
	return x;
}
def rotZQ[n:!â„•](const Ï†:int[n],x:ğ”¹)mfree{
	for i in [0..n){ if Ï†[i]{ x:=rotZ(2Â·Ï€Â·2^i/2^n,x); } }
	return x;
}
